{"version":3,"sources":["atoms/Avatar/Avatar.tsx","atoms/Button/Button.tsx","atoms/SentenceWord/SentenceWord.tsx","atoms/Title/Title.tsx","molecules/Sentence/Sentence.tsx","settings/constants.ts","pages/Quiz/Quiz.helpers.ts","atoms/Message/Message.tsx","atoms/AnswerWord/AnswerWord.tsx","libs/Draggable/Draggable.tsx","atoms/Anchor/Anchor.tsx","molecules/DropArea/DropArea.tsx","pages/Quiz/Quiz.tsx","db.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Avatar","src","cls","className","alt","Button","content","onclickHandler","isTranslate","push","onClick","join","SentenceWord","React","memo","Title","Sentence","children","TRANSITION_TIME","INITIAL_TRANSLATE_COORDS","x","y","INITIAL_SHIFT_COORDS","shiftX","shiftY","initialX","initialY","INITIAL_DRAGGABLE_ID","originId","wordId","getCorrectAnchors","words","targetAnchors","map","_","index","anchorId","isHidden","answerId","isPrepared","getConvertedAnchors","anchors","Array","isArray","reduce","acc","anchor","Object","values","getConvertedWords","word","getAnchorsDomList","anchorsDomRoot","from","length","matches","calcOriginCoords","root","idBeforeDraggableElem","settings","direction","coords","getAnchorsDomCoords","originCoords","id","getBoundingClientRect","getIdBeforeDraggableElem","draggableElem","action","wordsList","wordsArea","isGap","shiftedId","isBlocked","find","filter","getUpdatedAnswersAnchors","targetAnchor","convertedAnchors","reverse","getShiftedWords","dragId","elementAction","directionShift","includes","Message","isError","messageCls","textCls","AnswerWord","style","onMouseDown","onTouchStart","Draggable","draggableElemInfo","isTransitioned","dragStartHandler","dragMoveHandler","dragEndHandler","isBlockAnimaton","useState","isDragStart","setDragStart","setDraggableElem","inDropArea","useRef","currentArea","prevDropArea","debounce","translateCoords","setTranslateCoords","shiftCoords","setShiftCoords","setCurrentArea","useCallback","dropAreaName","current","isDraggableElemInDropArea","bellowElem","dataset","dropname","getBellowElement","target","classList","add","selector","elem","s","document","elementFromPoint","closest","defineElemFromPoint","remove","dragStart","ev","nativeEvent","MouseEvent","clientX","clientY","prevState","ondragstart","dragMove","TouchEvent","touches","touchShifteCoords","preventDefault","currentAreaName","keys","getBellowElemDataAttr","dragEnd","changedTouches","bellowElement","Number","useEffect","window","addEventListener","removeEventListener","useMemo","willChange","transform","transition","Children","item","cloneElement","props","Anchor","isDataAttr","data-anchor","data-id","DropArea","forwardRef","ref","areaName","preparedWords","createWord","isDataAttribute","text","data-dropname","Math","ceil","row","slice","anchorWrapper","rowId","Quiz","sentenceText","resultMessage","setResultMessage","setError","setBlockAnimation","dragEndEvent","setDragEndEvent","waitingRef","answersRef","draggableId","setDraggableId","waitingOriginCoords","setWaitingOriginCoords","answersOriginCoords","setAnswersOriginCoords","getCorrectWords","waitingWords","setWaitingWords","answersWords","setAnswersWords","answersAnchors","setAnswersAnchors","getNewOriginCoords","prevOriginCoords","calculatedOriginCoords","getAnswerPreparedAnchor","getEmptyAnswerAnchor","resetOriginCoords","time","setTimeout","translateDragElemFromPending","params","targetAnchorCoords","draggableElemCoords","translateDragElemFromAnswers","anchorsRoot","translateWaitingWords","checkAnswerHandler","translation","toLowerCase","correctCurrentArea","isTargetWaitingAnchorBusy","targetWord","shiftedwaitingWords","convertedWords","idBeforeAnswers","shiftedAnswersWords","shiftedAnswerWords","q1","sentenceWords","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.53cce0db.chunk.js","sourcesContent":["import React from 'react';\r\nimport { IAvatarProps } from './Avatar.types';\r\nimport './Avatar.scss';\r\nconst Avatar = ({ src }: IAvatarProps) => {\r\n  const cls = 'avatar__img';\r\n  return (\r\n    <div className=\"avatar\">\r\n      {src ? <img className={cls} src={src} alt=\"avatar\" /> : <div className={`${cls}-default`}></div>}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Avatar;\r\n","import React from 'react';\r\nimport './Button.scss';\r\nimport { IButtonProps } from './Button.types';\r\n\r\nconst Button = ({ content, onclickHandler, isTranslate }: IButtonProps) => {\r\n  const cls = ['button'];\r\n  if (isTranslate) cls.push('button_moved');\r\n  return (\r\n    <button onClick={onclickHandler} className={cls.join(' ')}>\r\n      {content}\r\n    </button>\r\n  );\r\n};\r\n\r\nexport default Button;\r\n","import React from 'react';\r\nimport { ISentenceWordProps } from './SentenceWord.types';\r\nimport './SentenceWord.scss';\r\nconst SentenceWord = ({ content }: ISentenceWordProps) => {\r\n  return <span className=\"sentence-word\">{content}</span>;\r\n};\r\n\r\nexport default React.memo(SentenceWord);\r\n","import { ITitleProps } from './Title.types';\r\nimport './Title.scss';\r\nconst Title = ({ content }: ITitleProps) => {\r\n  return <h1 className=\"title\">{content}</h1>;\r\n};\r\n\r\nexport default Title;\r\n","import React from 'react';\r\nimport './Sentence.scss';\r\nimport { SentencePropsType } from './Sentence.types';\r\n\r\nconst Sentence = ({ children }: SentencePropsType) => {\r\n  return (\r\n    <div className=\"sentence\">\r\n      <span className=\"sentence__tip\"></span>\r\n      <ul className=\"sentence__word-list\">{children}</ul>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Sentence;\r\n","const TRANSITION_TIME = 500;\r\nconst INITIAL_TRANSLATE_COORDS = { x: 0, y: 0 };\r\nconst INITIAL_SHIFT_COORDS = {\r\n  shiftX: 0,\r\n  shiftY: 0,\r\n  initialX: 0,\r\n  initialY: 0,\r\n};\r\nconst INITIAL_DRAGGABLE_ID = {\r\n  originId: 0,\r\n  wordId: 0,\r\n};\r\nexport { TRANSITION_TIME, INITIAL_SHIFT_COORDS, INITIAL_TRANSLATE_COORDS, INITIAL_DRAGGABLE_ID };\r\n","import { IAnchor } from '../../atoms/Anchor/Anchor.types';\r\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\r\nimport { IOriginCoords } from './Quiz.types';\r\nconst getCorrectWords = (words: string[]): IWord[] =>\r\n  words.map((text, index) => ({\r\n    text,\r\n    wordId: index,\r\n    originId: index,\r\n    from: 'waiting',\r\n  }));\r\n\r\nconst getCorrectAnchors = (words: string[], targetAnchors: 'waiting' | 'answers'): IAnchor[] =>\r\n  words.map((_, index) => ({\r\n    anchorId: index,\r\n    isHidden: targetAnchors === 'answers',\r\n    answerId: null,\r\n    isPrepared: false,\r\n  }));\r\n\r\nconst getConvertedAnchors = <R extends IAnchor[] | { [key: string]: IAnchor }>(\r\n  anchors: R\r\n): R extends IAnchor[] ? { [key: string]: IAnchor } : IAnchor[] =>\r\n  Array.isArray(anchors)\r\n    ? anchors.reduce((acc, anchor) => ({ ...acc, [anchor.anchorId]: { ...anchor } }), {})\r\n    : Object.values(anchors);\r\n\r\nconst getConvertedWords = (words: IWord[]): { [key: string]: IWord } =>\r\n  words.reduce((acc, word) => ({ ...acc, [word.wordId]: { ...word } }), {});\r\n\r\nconst getAnchorsDomList = <T extends HTMLElement>(anchorsDomRoot: T): T[] =>\r\n  (Array.from(anchorsDomRoot.children) as T[]).reduce(\r\n    (anchors: T[], anchor) =>\r\n      anchor.children.length !== 0 && !anchor.children[0].matches('.answer-word')\r\n        ? [...anchors, ...getAnchorsDomList(anchor)]\r\n        : [...anchors, anchor],\r\n    []\r\n  );\r\n\r\nconst calcOriginCoords = (\r\n  root: HTMLElement,\r\n  idBeforeDraggableElem: number[],\r\n  settings?: { direction: 'right' | 'left' }\r\n) => {\r\n  const { direction } = settings ?? { direction: 'left' }; //default settings\r\n  const coords = getAnchorsDomCoords(root);\r\n  return idBeforeDraggableElem.reduce(\r\n    (originCoords: IOriginCoords, id) => ({\r\n      ...originCoords,\r\n      [id]: {\r\n        x: coords[direction === 'right' ? (coords.length === id + 1 ? id : id + 1) : id - 1].x - coords[id].x, // overfloow\r\n        y: coords[direction === 'right' ? (coords.length === id + 1 ? id : id + 1) : id - 1].y - coords[id].y, // overfloow\r\n      },\r\n    }),\r\n    {}\r\n  );\r\n};\r\n\r\nconst getAnchorsDomCoords = (anchorsDomRoot: HTMLElement) =>\r\n  getAnchorsDomList(anchorsDomRoot).map((anchor) => ({\r\n    x: anchor.getBoundingClientRect().x,\r\n    y: anchor.getBoundingClientRect().y,\r\n  }));\r\n\r\nconst getIdBeforeDraggableElem = (\r\n  words: { wordsList: IWord[]; wordsArea: 'waiting' | 'answers' },\r\n  draggableElem: IWord,\r\n  action: 'put' | 'take'\r\n) => {\r\n  const { wordsList, wordsArea } = words;\r\n  const isGap = (word: IWord) => {\r\n    if (word.wordId - shiftedId > 1) {\r\n      isBlocked = true;\r\n      return false;\r\n    } else {\r\n      shiftedId += 1;\r\n      return true;\r\n    }\r\n  };\r\n\r\n  const isAnchorBusy =\r\n    draggableElem.from === 'waiting' ? true : wordsList.find((word) => word.wordId === draggableElem.originId);\r\n  let isBlocked = isAnchorBusy ? false : true;\r\n  let shiftedId = action === 'put' ? draggableElem.originId : draggableElem.wordId;\r\n  const result = wordsList\r\n    .filter((word) => {\r\n      if (wordsArea === 'waiting') {\r\n        if (isBlocked) return false;\r\n        if (action === 'put') {\r\n          if (word.wordId >= draggableElem.originId) {\r\n            return isGap(word);\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          if (word.wordId > draggableElem.wordId) {\r\n            return isGap(word);\r\n          } else {\r\n            return false;\r\n          }\r\n        }\r\n      } else {\r\n        return word.wordId > draggableElem.wordId;\r\n      }\r\n    })\r\n    .map((word) => word.wordId);\r\n  return result;\r\n};\r\n\r\nconst getUpdatedAnswersAnchors = (\r\n  anchors: IAnchor[],\r\n  action: 'setBusy' | 'delBusy' | 'prepare' | 'disprepare' | 'prepareLast'\r\n) => {\r\n  const convertedAnchors = getConvertedAnchors(anchors);\r\n  let targetAnchor;\r\n  switch (action) {\r\n    case 'setBusy': {\r\n      targetAnchor = [...anchors].reverse().find((anchor) => anchor.isPrepared);\r\n      break;\r\n    }\r\n    case 'delBusy': {\r\n      targetAnchor = [...anchors].reverse().find((anchor) => anchor.answerId !== null);\r\n      break;\r\n    }\r\n    case 'disprepare': {\r\n      targetAnchor = [...anchors].reverse().find((anchor) => anchor.isPrepared && anchor.answerId === null);\r\n      break;\r\n    }\r\n    case 'prepareLast': {\r\n      targetAnchor = [...anchors].reverse().find((anchor) => anchor.answerId !== null) as IAnchor;\r\n      break;\r\n    }\r\n    default: {\r\n      targetAnchor = anchors.find((anchor) => anchor.answerId === null);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // check undefined\r\n  if (targetAnchor) {\r\n    convertedAnchors[targetAnchor.anchorId] = {\r\n      ...targetAnchor,\r\n      isPrepared: action === 'prepare' || action === 'prepareLast',\r\n      answerId: action === 'setBusy' || action === 'prepareLast' ? targetAnchor.anchorId : null,\r\n    };\r\n  }\r\n\r\n  return getConvertedAnchors(convertedAnchors);\r\n};\r\n\r\nconst getShiftedWords = (\r\n  words: IWord[],\r\n  dragId: number,\r\n  idBeforeDraggableElem: number[],\r\n  settings: { elementAction: 'remove' | 'add'; directionShift: 'left' | 'right' }\r\n) => {\r\n  const { elementAction, directionShift } = settings;\r\n\r\n  const correctWords = elementAction === 'add' ? words : words.filter((word) => word.wordId !== dragId);\r\n  return correctWords.map((word) =>\r\n    idBeforeDraggableElem.includes(word.wordId)\r\n      ? {\r\n          ...word,\r\n          wordId:\r\n            directionShift === 'right'\r\n              ? words.length === word.wordId // overfloow\r\n                ? word.wordId\r\n                : word.wordId + 1\r\n              : word.wordId - 1,\r\n        }\r\n      : word\r\n  );\r\n};\r\n\r\nexport {\r\n  calcOriginCoords,\r\n  getAnchorsDomCoords,\r\n  getIdBeforeDraggableElem,\r\n  getShiftedWords,\r\n  getUpdatedAnswersAnchors,\r\n  getConvertedWords,\r\n  getAnchorsDomList,\r\n  getConvertedAnchors,\r\n  getCorrectWords,\r\n  getCorrectAnchors,\r\n};\r\n","import React from 'react';\r\nimport './Message.scss';\r\nimport { IMessageProps } from './Message.types';\r\n\r\nconst Message = ({ content, isError }: IMessageProps) => {\r\n  const messageCls = [];\r\n  const textCls = [];\r\n  if (content) messageCls.push('message_show');\r\n  if (isError) textCls.push('message__text_wrong');\r\n  return (\r\n    <div className={`message ${messageCls.join(' ')}`}>\r\n      <span className={`message__text ${textCls.join(' ')}`}>{content}</span>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Message;\r\n","import React from 'react';\r\nimport './AnswerWord.scss';\r\nimport { IAnswerWordProps } from './AnswerWord.types';\r\nconst AnswerWord = ({ content, style, onMouseDown }: IAnswerWordProps) => {\r\n  const cls = ['answer-word'];\r\n\r\n  return (\r\n    <span\r\n      style={style ?? null}\r\n      onMouseDown={onMouseDown ?? null}\r\n      onTouchStart={onMouseDown ?? null}\r\n      className={cls.join(' ')}\r\n    >\r\n      {content}\r\n    </span>\r\n  );\r\n};\r\n\r\nexport default AnswerWord;\r\n","import React, { Fragment, useCallback, useEffect, useMemo, useRef, useState } from 'react';\r\nimport { INITIAL_SHIFT_COORDS, INITIAL_TRANSLATE_COORDS, TRANSITION_TIME } from '../../settings/constants';\r\nimport { DraggablePropsType, GetBellowElement } from './Draggable.types';\r\nimport './Draggable.scss';\r\n\r\nconst Draggable = ({\r\n  draggableElemInfo,\r\n  children,\r\n  isTransitioned,\r\n  originCoords,\r\n  dragStartHandler,\r\n  dragMoveHandler,\r\n  dragEndHandler,\r\n  isBlockAnimaton,\r\n}: DraggablePropsType) => {\r\n  // ANIMATION CONTROL------------------------------------------------------------\r\n  const [isDragStart, setDragStart] = useState(false);\r\n  const [draggableElem, setDraggableElem] = useState<HTMLElement | null>(null);\r\n\r\n  // SETTINGS FOR DETERMINING THE CURRENT ZONE (bellow element)-------------------\r\n  const inDropArea = useRef(false);\r\n  const currentArea = useRef(draggableElemInfo.from === 'waiting' ? 'waitingArea' : 'answersArea');\r\n  const prevDropArea = useRef(draggableElemInfo.from === 'waiting' ? 'waitingArea' : 'answersArea');\r\n  const debounce = useRef<string>();\r\n\r\n  // TRANSLATE COORDS-------------------------------------------------------------\r\n  const [translateCoords, setTranslateCoords] = useState(INITIAL_TRANSLATE_COORDS);\r\n  const [shiftCoords, setShiftCoords] = useState(INITIAL_SHIFT_COORDS);\r\n\r\n  // HELPERS FUNCTIONS---------------------------------------------------\r\n  const getBellowElemDataAttr = (bellowElem: HTMLElement | null) => {\r\n    if (bellowElem) {\r\n      return Object.keys(bellowElem.dataset).length !== 0\r\n        ? bellowElem.dataset.dropname\r\n          ? (bellowElem.dataset.dropname as string)\r\n          : (bellowElem.dataset.anchor as string)\r\n        : null;\r\n    } else {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const defineElemFromPoint = (selector: string | string[], coords: [x: number, y: number]) =>\r\n    Array.isArray(selector)\r\n      ? selector.reduce(\r\n          (elem: HTMLElement | null, s) =>\r\n            elem === null && document.elementFromPoint(...coords) !== null\r\n              ? (document.elementFromPoint(...coords) as HTMLElement).closest(s)\r\n                ? (document.elementFromPoint(...coords) as HTMLElement).closest(s)\r\n                : elem\r\n              : elem,\r\n          null\r\n        )\r\n      : ((document.elementFromPoint(...coords) as HTMLElement).closest(selector) as HTMLElement);\r\n\r\n  const setCurrentArea = useCallback((dropAreaName: string | null) => {\r\n    if (inDropArea.current && dropAreaName) {\r\n      if (prevDropArea.current === dropAreaName) {\r\n        return dropAreaName;\r\n      } else {\r\n        prevDropArea.current = dropAreaName;\r\n        return dropAreaName;\r\n      }\r\n    } else {\r\n      return `out-${prevDropArea.current}`;\r\n    }\r\n  }, []);\r\n\r\n  const isDraggableElemInDropArea = useCallback(\r\n    (bellowElem: null | HTMLElement) =>\r\n      // если курсор выходит за viewport, то bellowElem = null\r\n      bellowElem\r\n        ? bellowElem.dataset.dropname || bellowElem.matches('[data-anchor=\"waitingAnchor\"]')\r\n          ? true\r\n          : false\r\n        : false,\r\n    []\r\n  );\r\n\r\n  const getBellowElement: GetBellowElement = useCallback((target, x, y) => {\r\n    const matchList = ['[data-anchor=\"waitingAnchor\"]', '.drop-area'];\r\n\r\n    target.classList.add('hidden');\r\n    const bellowElem = defineElemFromPoint(matchList, [x, y]);\r\n    target.classList.remove('hidden');\r\n\r\n    return bellowElem ?? (document.elementFromPoint(x, y) as HTMLElement);\r\n  }, []);\r\n\r\n  const makeDraggableElement = () =>\r\n    React.Children.map(children, (item) =>\r\n      React.cloneElement(item, {\r\n        ...item.props,\r\n        style,\r\n        onMouseDown: isBlockAnimaton ? null : dragStart,\r\n        onTouchStart: isBlockAnimaton ? null : dragStart,\r\n      })\r\n    );\r\n\r\n  // HANDLER FUNCTIONS---------------------------------------------------\r\n  const dragStart = useCallback(\r\n    (ev: React.MouseEvent<HTMLSpanElement> | React.TouchEvent<HTMLSpanElement>) => {\r\n      let shiftCoords =\r\n        ev.nativeEvent instanceof MouseEvent\r\n          ? [(ev as React.MouseEvent).clientX, (ev as React.MouseEvent).clientY]\r\n          : [0, 0];\r\n\r\n      const draggableElem = ev.target as HTMLSpanElement;\r\n      draggableElem.classList.add('draggable');\r\n      setDragStart(true);\r\n      setDraggableElem(draggableElem);\r\n\r\n      setShiftCoords((prevState) => ({\r\n        ...prevState,\r\n        shiftX: shiftCoords[0] - draggableElem.getBoundingClientRect().x,\r\n        shiftY: shiftCoords[1] - draggableElem.getBoundingClientRect().y,\r\n        initialX: draggableElem.getBoundingClientRect().x,\r\n        initialY: draggableElem.getBoundingClientRect().y,\r\n      }));\r\n\r\n      dragStartHandler({\r\n        from: draggableElemInfo.from,\r\n        dragId: draggableElemInfo.wordId,\r\n      });\r\n      draggableElem.ondragstart = () => false;\r\n    },\r\n    [dragStartHandler, draggableElemInfo]\r\n  );\r\n\r\n  const dragMove = useCallback(\r\n    (ev: MouseEvent | TouchEvent) => {\r\n      const { clientX, clientY, target } = ev instanceof TouchEvent ? ev.touches[0] : ev;\r\n      const touchShifteCoords = [40, 20];\r\n      if (ev instanceof TouchEvent) ev.preventDefault();\r\n\r\n      const bellowElem = getBellowElement(target as HTMLElement, clientX, clientY);\r\n      inDropArea.current = isDraggableElemInDropArea(bellowElem);\r\n      const currentAreaName = setCurrentArea(getBellowElemDataAttr(bellowElem));\r\n\r\n      if (currentAreaName !== debounce.current) {\r\n        debounce.current = currentAreaName;\r\n        currentArea.current = currentAreaName;\r\n        dragMoveHandler({\r\n          from: draggableElemInfo.from,\r\n          currentArea: currentArea.current as 'out-answersArea' | 'answersArea',\r\n        });\r\n      }\r\n\r\n      setTranslateCoords((prevState) => ({\r\n        ...prevState,\r\n        x:\r\n          ev instanceof TouchEvent\r\n            ? clientX - shiftCoords.initialX - touchShifteCoords[0]\r\n            : clientX - shiftCoords.initialX - shiftCoords.shiftX,\r\n        y:\r\n          ev instanceof TouchEvent\r\n            ? clientY - shiftCoords.initialY - touchShifteCoords[1]\r\n            : clientY - shiftCoords.initialY - shiftCoords.shiftY,\r\n      }));\r\n      if (bellowElem) bellowElem.ondragstart = () => false;\r\n    },\r\n    [\r\n      dragMoveHandler,\r\n      draggableElemInfo.from,\r\n      getBellowElement,\r\n      isDraggableElemInDropArea,\r\n      setCurrentArea,\r\n      shiftCoords.initialX,\r\n      shiftCoords.initialY,\r\n      shiftCoords.shiftX,\r\n      shiftCoords.shiftY,\r\n    ]\r\n  );\r\n\r\n  const dragEnd = useCallback(\r\n    (ev: MouseEvent | TouchEvent) => {\r\n      const { clientX, clientY, target } = ev instanceof TouchEvent ? ev.changedTouches[0] : ev;\r\n\r\n      draggableElem?.classList.remove('draggable');\r\n      const bellowElement = getBellowElement(target as HTMLElement, clientX, clientY);\r\n      setDragStart(false);\r\n      setTranslateCoords(INITIAL_TRANSLATE_COORDS);\r\n\r\n      dragEndHandler({\r\n        from: draggableElemInfo.from,\r\n        originId: draggableElemInfo.originId,\r\n        dragId: draggableElemInfo.wordId,\r\n        currentArea: currentArea.current as 'waitingArea' | 'answersArea' | 'waitingAnchor',\r\n        anchorId: bellowElement\r\n          ? bellowElement.dataset.id || bellowElement.dataset.id === '0'\r\n            ? Number(bellowElement.dataset.id)\r\n            : null\r\n          : null,\r\n      });\r\n    },\r\n    [\r\n      dragEndHandler,\r\n      draggableElem?.classList,\r\n      draggableElemInfo.from,\r\n      draggableElemInfo.originId,\r\n      draggableElemInfo.wordId,\r\n      getBellowElement,\r\n    ]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (isDragStart && !isBlockAnimaton) {\r\n      window.addEventListener('mousemove', dragMove);\r\n      window.addEventListener('mouseup', dragEnd);\r\n      window.addEventListener('touchmove', dragMove, false);\r\n      window.addEventListener('touchend', dragEnd);\r\n    } else {\r\n      window.removeEventListener('mousemove', dragMove);\r\n      window.removeEventListener('mouseup', dragEnd);\r\n      window.removeEventListener('touchmove', dragMove);\r\n      window.removeEventListener('touchend', dragEnd);\r\n    }\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', dragMove);\r\n      window.removeEventListener('mouseup', dragEnd);\r\n      window.removeEventListener('touchmove', dragMove);\r\n      window.removeEventListener('touchend', dragEnd);\r\n    };\r\n  }, [dragEnd, dragMove, isBlockAnimaton, isDragStart]);\r\n\r\n  const style = useMemo(\r\n    () => ({\r\n      willChange: 'transform',\r\n      transform: isDragStart\r\n        ? `translate(\r\n      ${translateCoords.x + originCoords.x}px, \r\n      ${translateCoords.y + originCoords.y}px)`\r\n        : `translate(${originCoords.x}px, ${originCoords.y}px)`,\r\n      transition: isDragStart || isTransitioned ? '' : `transform ${TRANSITION_TIME}ms ease`,\r\n    }),\r\n    [isDragStart, isTransitioned, originCoords.x, originCoords.y, translateCoords.x, translateCoords.y]\r\n  );\r\n\r\n  return <Fragment>{makeDraggableElement()}</Fragment>;\r\n};\r\n\r\nexport default React.memo(Draggable);\r\n","import React from 'react';\r\nimport './Anchor.scss';\r\nimport { IAnchorProps } from './Anchor.types';\r\nconst Anchor = ({ children, isHidden, isPrepared, isDataAttr, id }: IAnchorProps) => {\r\n  const cls = ['anchor'];\r\n  if (!isHidden) cls.push('anchor_show');\r\n  if (isPrepared) cls.push('anchor_prepared');\r\n  return (\r\n    <li className={cls.join(' ')} data-anchor={isDataAttr ? 'waitingAnchor' : null} data-id={isHidden ? null : id}>\r\n      {children ?? null}\r\n    </li>\r\n  );\r\n};\r\n\r\nexport default React.memo(Anchor);\r\n","import React, { forwardRef } from 'react';\r\nimport AnswerWord from '../../atoms/AnswerWord/AnswerWord';\r\nimport { IDropAreaProps } from './DropArea.types';\r\nimport Draggable from '../../libs/Draggable/Draggable';\r\nimport './DropArea.scss';\r\nimport Anchor from '../../atoms/Anchor/Anchor';\r\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\r\nimport { IAnchor } from '../../atoms/Anchor/Anchor.types';\r\n\r\nconst DropArea = forwardRef<any, IDropAreaProps>(\r\n  (\r\n    {\r\n      areaName,\r\n      anchors,\r\n      words,\r\n      originCoords,\r\n      dragStartHandler,\r\n      dragMoveHandler,\r\n      dragEndHandler,\r\n      isTransitioned,\r\n      isBlockAnimaton,\r\n    },\r\n    ref\r\n  ) => {\r\n    const preparedWords: { [key: string]: IWord } = words.reduce(\r\n      (acc, item) => ({ ...acc, [item.wordId]: { ...item } }),\r\n      {}\r\n    );\r\n    const createWord = (anchor: IAnchor, isDataAttribute: boolean = false) => (\r\n      <Anchor\r\n        key={anchor.anchorId}\r\n        isHidden={anchor.isHidden}\r\n        isPrepared={anchor.isPrepared}\r\n        isDataAttr={isDataAttribute}\r\n        id={anchor.anchorId}\r\n      >\r\n        {preparedWords[anchor.anchorId] && (\r\n          <Draggable\r\n            draggableElemInfo={{ ...preparedWords[anchor.anchorId] }}\r\n            isTransitioned={isTransitioned}\r\n            originCoords={originCoords[anchor.anchorId] ?? { x: 0, y: 0 }}\r\n            dragStartHandler={dragStartHandler}\r\n            dragMoveHandler={dragMoveHandler}\r\n            dragEndHandler={dragEndHandler}\r\n            isBlockAnimaton={isBlockAnimaton}\r\n          >\r\n            <AnswerWord content={preparedWords[anchor.anchorId].text} key={preparedWords[anchor.anchorId].wordId} />\r\n          </Draggable>\r\n        )}\r\n      </Anchor>\r\n    );\r\n\r\n    // [words] => [[words],[words],[wrods]...]\r\n    const getPreparedAnchors = () =>\r\n      [...Array(Math.ceil(anchors.length / 6)).keys()].map((row) => anchors.slice(row * 6, (row + 1) * 6));\r\n\r\n    const createAnchors = () =>\r\n      getPreparedAnchors().map((anchorWrapper, rowId) => (\r\n        <ul key={rowId} className=\"drop-area__wrapper\">\r\n          {anchorWrapper.map((anchor) => createWord(anchor))}\r\n        </ul>\r\n      ));\r\n\r\n    return areaName === 'answersArea' ? (\r\n      <div className=\"drop-area\" data-dropname={areaName} ref={ref}>\r\n        {createAnchors()}\r\n      </div>\r\n    ) : (\r\n      <ul className=\"drop-area\" data-dropname={areaName} ref={ref}>\r\n        {anchors.map((anchor) => createWord(anchor, true))}\r\n      </ul>\r\n    );\r\n  }\r\n);\r\n\r\nexport default DropArea;\r\n","import './Quiz.scss';\r\nimport React, { RefObject, useCallback, useEffect, useRef, useState } from 'react';\r\nimport Avatar from '../../atoms/Avatar/Avatar';\r\nimport Button from '../../atoms/Button/Button';\r\nimport SentenceWord from '../../atoms/SentenceWord/SentenceWord';\r\nimport Title from '../../atoms/Title/Title';\r\nimport Sentence from '../../molecules/Sentence/Sentence';\r\nimport { INITIAL_DRAGGABLE_ID, TRANSITION_TIME } from '../../settings/constants';\r\nimport { IAnchor } from '../../atoms/Anchor/Anchor.types';\r\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\r\nimport {\r\n  calcOriginCoords,\r\n  getAnchorsDomCoords,\r\n  getConvertedWords,\r\n  getCorrectAnchors,\r\n  getCorrectWords,\r\n  getIdBeforeDraggableElem,\r\n  getShiftedWords,\r\n  getUpdatedAnswersAnchors,\r\n  getAnchorsDomList,\r\n} from './Quiz.helpers';\r\nimport Message from '../../atoms/Message/Message';\r\nimport {\r\n  IOriginCoords,\r\n  IQuizProps,\r\n  TDragEndHandler,\r\n  TDraggableId,\r\n  TDragMoveHandler,\r\n  TDragStartHandler,\r\n} from './Quiz.types';\r\nimport DropArea from '../../molecules/DropArea/DropArea';\r\nconst Quiz = ({ sentenceText, words }: IQuizProps) => {\r\n  // result-info----------------------------------------------------------\r\n  const [resultMessage, setResultMessage] = useState<string | null>(null);\r\n  const [isError, setError] = useState<boolean | null>(null);\r\n\r\n  // animation-data------------------------------------------------------\r\n  const [isBlockAnimaton, setBlockAnimation] = useState(false);\r\n  const [dragEndEvent, setDragEndEvent] = useState<string>('');\r\n  const waitingRef = useRef(null) as RefObject<HTMLUListElement>;\r\n  const answersRef = useRef(null) as RefObject<HTMLDivElement>;\r\n  const isTransitioned = useRef(false);\r\n  const [draggableId, setDraggableId] = useState<TDraggableId>(INITIAL_DRAGGABLE_ID);\r\n\r\n  // origin-coords-------------------------------------------------------\r\n  const [waitingOriginCoords, setWaitingOriginCoords] = useState<IOriginCoords>({});\r\n  const [answersOriginCoords, setAnswersOriginCoords] = useState<IOriginCoords>({});\r\n  // words---------------------------------------------------------------\r\n  const [waitingWords, setWaitingWords] = useState<IWord[]>(getCorrectWords(words));\r\n  const [answersWords, setAnswersWords] = useState<IWord[]>([]);\r\n  // anchors-------------------------------------------------------------\r\n  const [answersAnchors, setAnswersAnchors] = useState(getCorrectAnchors(words, 'answers'));\r\n\r\n  // HELPER FUNCTIONS---------------------------------------------\r\n  const getNewOriginCoords = useCallback(\r\n    (target: 'waiting' | 'answers', dragId: number): IOriginCoords => {\r\n      const prevOriginCoords = target === 'waiting' ? waitingOriginCoords : answersOriginCoords;\r\n      const root = target === 'waiting' ? (waitingRef.current as HTMLElement) : (answersRef.current as HTMLElement);\r\n      const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n        {\r\n          wordsList: target === 'waiting' ? waitingWords : answersWords,\r\n          wordsArea: target,\r\n        },\r\n        getConvertedWords(target === 'waiting' ? waitingWords : answersWords)[dragId],\r\n        'take'\r\n      );\r\n      const calculatedOriginCoords = calcOriginCoords(root, idBeforeDraggableElem);\r\n      return {\r\n        ...prevOriginCoords,\r\n        ...calculatedOriginCoords,\r\n      };\r\n    },\r\n    [answersOriginCoords, answersWords, waitingOriginCoords, waitingWords]\r\n  );\r\n\r\n  const getAnswerPreparedAnchor = useCallback(\r\n    () => [...answersAnchors].reverse().find((anchor) => anchor.isPrepared) as IAnchor,\r\n    [answersAnchors]\r\n  );\r\n\r\n  const getEmptyAnswerAnchor = (anchors: IAnchor[]) => anchors.find((anchor) => anchor.answerId === null) as IAnchor;\r\n\r\n  const isTargetWaitingAnchorBusy = (currentArea: string, anchorId: number) =>\r\n    currentArea === 'waitingAnchor' && getAnchorsDomList(waitingRef.current as HTMLUListElement)[anchorId].children[0];\r\n\r\n  const resetOriginCoords = (time: number = 0) => {\r\n    setAnswersOriginCoords({});\r\n    setWaitingOriginCoords({});\r\n    setTimeout(() => setBlockAnimation(false), time);\r\n  };\r\n\r\n  const translateDragElemFromPending = useCallback(\r\n    (params: { anchorId: number; dragId: number }) => {\r\n      const { anchorId, dragId } = params;\r\n      const targetAnchorCoords = getAnchorsDomCoords(answersRef.current as HTMLElement)[anchorId];\r\n      const draggableElemCoords = getAnchorsDomCoords(waitingRef.current as HTMLElement)[dragId];\r\n      setWaitingOriginCoords({\r\n        ...waitingOriginCoords,\r\n        [dragId]: {\r\n          x: targetAnchorCoords.x - draggableElemCoords.x,\r\n          y: targetAnchorCoords.y - draggableElemCoords.y,\r\n        },\r\n      });\r\n    },\r\n    [waitingOriginCoords]\r\n  );\r\n\r\n  const translateDragElemFromAnswers = useCallback(\r\n    (\r\n      params: { dragId: number; anchorId: number },\r\n      anchorsRoot: HTMLDivElement | HTMLUListElement = waitingRef.current as HTMLUListElement\r\n    ) => {\r\n      const { dragId, anchorId } = params;\r\n      const draggableElemCoords = getAnchorsDomCoords(answersRef.current as HTMLElement)[dragId];\r\n      const targetAnchorCoords = getAnchorsDomCoords(anchorsRoot)[anchorId];\r\n      setAnswersOriginCoords({\r\n        ...answersOriginCoords,\r\n        [dragId]: {\r\n          x: targetAnchorCoords.x - draggableElemCoords.x,\r\n          y: targetAnchorCoords.y - draggableElemCoords.y,\r\n        },\r\n      });\r\n    },\r\n    [answersOriginCoords]\r\n  );\r\n\r\n  const translateWaitingWords = useCallback(\r\n    (dragId: number) => {\r\n      const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n        { wordsList: waitingWords, wordsArea: 'waiting' },\r\n        getConvertedWords(answersWords)[dragId],\r\n        'put'\r\n      );\r\n\r\n      setWaitingOriginCoords({\r\n        ...waitingOriginCoords,\r\n        ...calcOriginCoords(waitingRef.current as HTMLElement, idBeforeDraggableElem, { direction: 'right' }),\r\n      });\r\n    },\r\n    [answersWords, waitingOriginCoords, waitingWords]\r\n  );\r\n\r\n  // HANDLER FUNCTIONS---------------------------------------------\r\n  const checkAnswerHandler = useCallback(() => {\r\n    const correctText = sentenceText\r\n      .filter((item) => item.translation !== '')\r\n      .map((item) => item.translation.toLowerCase())\r\n      .join(' ');\r\n    const answersText = answersWords.map((word) => word.text).join(' ');\r\n    if (correctText === answersText) {\r\n      setResultMessage('is complete!!!');\r\n    } else {\r\n      setError(true);\r\n      setResultMessage('something wrong');\r\n    }\r\n  }, [answersWords, sentenceText]);\r\n\r\n  const dragStartHandler: TDragStartHandler = useCallback(\r\n    ({ dragId, from }) => {\r\n      isTransitioned.current = false; // enable transition\r\n      setResultMessage(null);\r\n      setError(null);\r\n      if (from === 'waiting') {\r\n        setWaitingOriginCoords(getNewOriginCoords('waiting', dragId));\r\n      } else {\r\n        setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'prepareLast'));\r\n        setAnswersOriginCoords(getNewOriginCoords('answers', dragId));\r\n      }\r\n    },\r\n    [answersAnchors, getNewOriginCoords]\r\n  );\r\n\r\n  const dragMoveHandler: TDragMoveHandler = useCallback(\r\n    ({ from, currentArea }) => {\r\n      if (from === 'waiting') {\r\n        if (currentArea === 'answersArea') setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'prepare'));\r\n        if (currentArea === 'out-answersArea') {\r\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'disprepare'));\r\n        }\r\n      }\r\n    },\r\n    [answersAnchors]\r\n  );\r\n\r\n  const dragEndHandler: TDragEndHandler = useCallback(\r\n    ({ dragId, from, currentArea, originId, anchorId }) => {\r\n      setBlockAnimation(true); // disable handlers\r\n      if (from === 'waiting') {\r\n        if (currentArea === 'answersArea') {\r\n          // ANIMATION-----------------------------------------\r\n          translateDragElemFromPending({ anchorId: getEmptyAnswerAnchor(answersAnchors).anchorId, dragId });\r\n          setDraggableId({ originId, wordId: dragId });\r\n          setDragEndEvent('waiting-answers');\r\n        } else {\r\n          resetOriginCoords(100);\r\n        }\r\n      }\r\n\r\n      if (from === 'answers') {\r\n        const correctCurrentArea = isTargetWaitingAnchorBusy(currentArea, anchorId as number)\r\n          ? 'waitingArea'\r\n          : currentArea;\r\n        if (correctCurrentArea === 'waitingArea') {\r\n          // translate drag elem to pending\r\n          translateDragElemFromAnswers({ dragId, anchorId: originId });\r\n\r\n          // translate pending words\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            { wordsList: waitingWords, wordsArea: 'waiting' },\r\n            getConvertedWords(answersWords)[dragId],\r\n            'put'\r\n          );\r\n          setWaitingOriginCoords({\r\n            ...waitingOriginCoords,\r\n            ...calcOriginCoords(waitingRef.current as HTMLElement, idBeforeDraggableElem, { direction: 'right' }),\r\n          });\r\n\r\n          //UPDATE STATE----------------------------------\r\n          setDraggableId({ originId, wordId: dragId });\r\n          setDragEndEvent('answers-waiting');\r\n        } else if (correctCurrentArea === 'waitingAnchor') {\r\n          // TRANSLATE TO THE WRONG ANCHOR-----------------------------\r\n          translateDragElemFromAnswers({ dragId, anchorId: anchorId as number });\r\n\r\n          // TRANSLATE TO THE ORIGIN ANCHOR----------------------------\r\n          setDraggableId({ wordId: dragId, originId: originId });\r\n          setDragEndEvent('answers-wrong-waiting');\r\n        } else {\r\n          setBlockAnimation(true); // disable handlers\r\n\r\n          translateDragElemFromAnswers(\r\n            { dragId, anchorId: getAnswerPreparedAnchor().anchorId },\r\n            answersRef.current as HTMLDivElement\r\n          );\r\n          setDraggableId({ originId, wordId: dragId });\r\n          setDragEndEvent('answers-answers');\r\n        }\r\n      }\r\n    },\r\n    [\r\n      translateDragElemFromPending,\r\n      answersAnchors,\r\n      translateDragElemFromAnswers,\r\n      waitingWords,\r\n      answersWords,\r\n      waitingOriginCoords,\r\n      getAnswerPreparedAnchor,\r\n    ]\r\n  );\r\n\r\n  useEffect(() => {\r\n    switch (dragEndEvent) {\r\n      case 'waiting-answers': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          isTransitioned.current = true; // off transition\r\n\r\n          // show last anchor in answers area\r\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'setBusy'));\r\n\r\n          // shift words in waiting area\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            { wordsList: waitingWords, wordsArea: 'waiting' },\r\n            getConvertedWords(waitingWords)[draggableId.wordId],\r\n            'take'\r\n          );\r\n\r\n          setWaitingWords(\r\n            getShiftedWords(waitingWords, draggableId.wordId, idBeforeDraggableElem, {\r\n              elementAction: 'remove',\r\n              directionShift: 'left',\r\n            })\r\n          );\r\n\r\n          // add word to end of answers area\r\n          const targetWord = getConvertedWords(waitingWords)[draggableId.wordId];\r\n          setAnswersWords([\r\n            ...answersWords,\r\n            { ...targetWord, wordId: getEmptyAnswerAnchor(answersAnchors).anchorId, from: 'answers' },\r\n          ]);\r\n          resetOriginCoords(100);\r\n        }, TRANSITION_TIME);\r\n        break;\r\n      }\r\n      case 'answers-waiting': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          isTransitioned.current = true; // off transition\r\n\r\n          // shift waiting words\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            { wordsList: waitingWords, wordsArea: 'waiting' },\r\n            getConvertedWords(answersWords)[draggableId.wordId],\r\n            'put'\r\n          );\r\n          const shiftedwaitingWords = getShiftedWords(waitingWords, draggableId.originId, idBeforeDraggableElem, {\r\n            elementAction: 'add',\r\n            directionShift: 'right',\r\n          });\r\n          const convertedWords = getConvertedWords(shiftedwaitingWords);\r\n          convertedWords[draggableId.originId] = {\r\n            ...getConvertedWords(answersWords)[draggableId.wordId],\r\n            from: 'waiting',\r\n            wordId: draggableId.originId,\r\n          };\r\n          setWaitingWords(Object.values(convertedWords));\r\n\r\n          // shift answers words\r\n          const idBeforeAnswers = getIdBeforeDraggableElem(\r\n            { wordsList: answersWords, wordsArea: 'answers' },\r\n            getConvertedWords(answersWords)[draggableId.wordId],\r\n            'take'\r\n          );\r\n          const shiftedAnswersWords = getShiftedWords(answersWords, draggableId.wordId, idBeforeAnswers, {\r\n            elementAction: 'remove',\r\n            directionShift: 'left',\r\n          });\r\n          setAnswersWords(shiftedAnswersWords);\r\n\r\n          // hide last anchor in answers area\r\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'delBusy'));\r\n\r\n          resetOriginCoords(100);\r\n        }, TRANSITION_TIME);\r\n        break;\r\n      }\r\n      case 'answers-wrong-waiting': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          translateWaitingWords(draggableId.wordId);\r\n          translateDragElemFromAnswers({ dragId: draggableId.wordId, anchorId: draggableId.originId });\r\n\r\n          // UPDATE STATE---------------------------------------------\r\n          setDragEndEvent('answers-waiting');\r\n        }, TRANSITION_TIME + 500);\r\n        break;\r\n      }\r\n      case 'answers-answers': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          isTransitioned.current = true; // off transition\r\n\r\n          const targetWord = getConvertedWords(answersWords)[draggableId.wordId];\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            {\r\n              wordsList: answersWords,\r\n              wordsArea: 'answers',\r\n            },\r\n            targetWord,\r\n            'take'\r\n          );\r\n          const shiftedAnswerWords = getShiftedWords(answersWords, draggableId.wordId, idBeforeDraggableElem, {\r\n            elementAction: 'remove',\r\n            directionShift: 'left',\r\n          });\r\n          shiftedAnswerWords.push({ ...targetWord, wordId: shiftedAnswerWords.length });\r\n\r\n          setAnswersWords(shiftedAnswerWords);\r\n          setAnswersAnchors(\r\n            answersAnchors.map((anchor) => (anchor.isPrepared ? { ...anchor, isPrepared: false } : anchor))\r\n          );\r\n          resetOriginCoords(100);\r\n        }, TRANSITION_TIME);\r\n        break;\r\n      }\r\n    }\r\n  }, [\r\n    answersAnchors,\r\n    answersWords,\r\n    dragEndEvent,\r\n    draggableId,\r\n    waitingWords,\r\n    translateDragElemFromAnswers,\r\n    translateWaitingWords,\r\n  ]);\r\n\r\n  return (\r\n    <div className=\"quiz\">\r\n      <Title content=\"Translate this sentence\" />\r\n      <div className=\"quiz-info\">\r\n        <Avatar />\r\n        <Sentence>\r\n          {sentenceText.map((word, index) => (\r\n            <li key={index}>\r\n              <SentenceWord content={word.text} />\r\n            </li>\r\n          ))}\r\n        </Sentence>\r\n      </div>\r\n      <div className=\"answers-wrapper\">\r\n        <DropArea\r\n          dragStartHandler={dragStartHandler}\r\n          dragMoveHandler={dragMoveHandler}\r\n          dragEndHandler={dragEndHandler}\r\n          originCoords={answersOriginCoords}\r\n          areaName=\"answersArea\"\r\n          words={answersWords}\r\n          anchors={answersAnchors}\r\n          isTransitioned={isTransitioned.current}\r\n          isBlockAnimaton={isBlockAnimaton}\r\n          ref={answersRef}\r\n        />\r\n      </div>\r\n      <div className=\"waiting-wrapper\">\r\n        <DropArea\r\n          dragStartHandler={dragStartHandler}\r\n          dragMoveHandler={dragMoveHandler}\r\n          dragEndHandler={dragEndHandler}\r\n          originCoords={waitingOriginCoords}\r\n          areaName=\"waitingArea\"\r\n          words={waitingWords}\r\n          anchors={getCorrectAnchors(words, 'waiting')}\r\n          isTransitioned={isTransitioned.current}\r\n          isBlockAnimaton={isBlockAnimaton}\r\n          ref={waitingRef}\r\n        />\r\n      </div>\r\n      <Message content={resultMessage} isError={isError} />\r\n      <div className=\"btn-wrapper\">\r\n        <Button\r\n          isTranslate={resultMessage}\r\n          onclickHandler={isBlockAnimaton ? null : checkAnswerHandler}\r\n          content=\"click\"\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Quiz;\r\n","const db = {\r\n  q1: {\r\n    sentenceWords: [\r\n      { text: 'In', translation: 'по' },\r\n      { text: 'the', translation: '' },\r\n      { text: 'morning', translation: 'утрам' },\r\n      { text: 'He', translation: 'он' },\r\n      { text: 'eats', translation: 'ест' },\r\n      { text: 'oatmeal', translation: 'кашу' },\r\n      { text: 'watches', translation: 'смотрит' },\r\n      { text: 'TV', translation: 'тв' },\r\n      { text: 'and', translation: 'и' },\r\n      { text: 'talks', translation: 'говорит' },\r\n      { text: 'to', translation: 'со' },\r\n      { text: 'his', translation: 'своей' },\r\n      { text: 'wife', translation: 'женой' },\r\n    ],\r\n    answersWords: ['по', 'утрам', 'он', 'ест', 'кашу', 'смотрит', 'тв', 'и', 'говорит', 'со', 'своей', 'женой'],\r\n  },\r\n};\r\n\r\nexport default db;\r\n","import React from 'react';\r\nimport './App.scss';\r\nimport Quiz from './pages/Quiz/Quiz';\r\nimport db from './db';\r\n\r\nconst { sentenceWords, answersWords } = db.q1;\r\nconst App = () => {\r\n  return (\r\n    <div className=\"App\">\r\n      <Quiz sentenceText={sentenceWords} words={answersWords} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\nreportWebVitals();\n"],"sourceRoot":""}
{"version":3,"sources":["App.styles.ts","atoms/Avatar/Avatar.styles.ts","atoms/Avatar/Avatar.tsx","atoms/Button/Button.styles.ts","atoms/Button/Button.tsx","atoms/SentenceWord/SentenceWord.styles.ts","atoms/SentenceWord/SentenceWord.tsx","atoms/Title/Title.styles.ts","atoms/Title/Title.tsx","molecules/Sentence/Sentence.styles.ts","molecules/Sentence/Sentence.tsx","settings/constants.ts","locales.ts","pages/Quiz/Quiz.helpers.ts","atoms/Message/Message.styles.ts","atoms/Message/Message.tsx","atoms/AnswerWord/AnswerWord.styles.ts","atoms/AnswerWord/AnswerWord.tsx","libs/Draggable/Draggable.tsx","atoms/Anchor/Anchor.styles.ts","atoms/Anchor/Anchor.tsx","molecules/DropArea/DropArea.styles.ts","molecules/DropArea/DropArea.tsx","pages/Quiz/Quiz.styles.ts","pages/Quiz/Quiz.tsx","App.tsx","reportWebVitals.ts","settings/fonts/Roboto/Roboto-Regular.woff","settings/fonts/fonts.ts","index.tsx"],"names":["StyledApp","styled","div","StyledAvatar","DefaultAvatar","Avatar","src","alt","StyledButton","button","props","isMove","Button","content","onclickHandler","onClick","StyledSentenceWord","span","SentenceWord","React","memo","StyledTitle","h1","Title","StyledSentence","SentenceTip","SentenceList","ul","Sentence","children","TRANSITION_TIME","INITIAL_TRANSLATE_COORDS","x","y","INITIAL_SHIFT_COORDS","shiftX","shiftY","initialX","initialY","INITIAL_DRAGGABLE_ID","originId","wordId","locales","language","messages","q1","question","answers","correct","getCorrectAnchors","target","quizId","Translator","translate","split","map","_","index","anchorId","isHidden","answerId","isPrepared","getQuestionText","getMessageById","getConvertedAnchors","anchors","Array","isArray","reduce","acc","anchor","Object","values","getConvertedWords","words","word","getAnchorsDomList","anchorsDomRoot","from","length","matches","calcOriginCoords","root","idBeforeDraggableElem","settings","direction","coords","getAnchorsDomCoords","originCoords","id","getBoundingClientRect","getIdBeforeDraggableElem","draggableElem","action","wordsList","wordsArea","isGap","shiftedId","isBlocked","find","filter","getUpdatedAnswersAnchors","targetAnchor","convertedAnchors","reverse","getShiftedWords","dragId","elementAction","directionShift","includes","StyledMessage","isShow","MessageText","isError","Message","StyledAnswerWord","AnswerWord","style","onMouseDown","className","onTouchStart","Draggable","draggableElemInfo","isTransitioned","dragStartHandler","dragMoveHandler","dragEndHandler","isBlockAnimaton","useState","isDragStart","setDragStart","setDraggableElem","inDropArea","useRef","currentArea","prevDropArea","debounce","translateCoords","setTranslateCoords","shiftCoords","setShiftCoords","setCurrentArea","useCallback","dropAreaName","current","isDraggableElemInDropArea","bellowElem","dataset","dropname","getBellowElement","visibility","selector","elem","s","document","elementFromPoint","closest","defineElemFromPoint","dragStart","ev","nativeEvent","MouseEvent","clientX","clientY","prevState","ondragstart","dragMove","TouchEvent","touches","touchShifteCoords","preventDefault","currentAreaName","keys","getBellowElemDataAttr","dragEnd","changedTouches","classList","remove","bellowElement","Number","useEffect","window","addEventListener","removeEventListener","useMemo","willChange","transform","transition","zIndex","position","background","Children","item","cloneElement","StyledAnchor","li","Anchor","isDataAttr","data-anchor","data-id","StyledDropArea","Wrapper","DropArea","forwardRef","ref","areaName","preparedWords","createWord","isDataAttribute","text","data-dropname","Math","ceil","row","slice","anchorWrapper","rowId","StyledQuiz","QuizInfo","QuizAnswersWrapper","QuizWaitingWrapper","QuizButtonWrapper","Quiz","resultMessage","setResultMessage","setError","setBlockAnimation","dragEndEvent","setDragEndEvent","waitingRef","answersRef","draggableId","setDraggableId","waitingOriginCoords","setWaitingOriginCoords","answersOriginCoords","setAnswersOriginCoords","getCorrectWords","waitingWords","setWaitingWords","answersWords","setAnswersWords","answersAnchors","setAnswersAnchors","getNewOriginCoords","prevOriginCoords","calculatedOriginCoords","getAnswerPreparedAnchor","getEmptyAnswerAnchor","resetOriginCoords","time","setTimeout","translateDragElemFromPending","params","targetAnchorCoords","draggableElemCoords","translateDragElemFromAnswers","anchorsRoot","translateWaitingWords","checkAnswerHandler","correctText","getCorrectText","answersText","join","localeCompare","correctCurrentArea","isTargetWaitingAnchorBusy","targetWord","shiftedwaitingWords","convertedWords","idBeforeAnswers","shiftedAnswersWords","shiftedAnswerWords","push","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","createGlobalStyle","normalize","RobotoURLwoff","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.8e9b67ac.chunk.js","sourcesContent":["import styled from 'styled-components';\r\n\r\nconst StyledApp = styled.div`\r\n  padding: 0 20px;\r\n`;\r\n\r\nexport default StyledApp;\r\n","import styled from 'styled-components';\r\n\r\nconst StyledAvatar = styled.div`\r\n  padding: 0px 40px;\r\n  padding-bottom: 79px;\r\n`;\r\n\r\nconst DefaultAvatar = styled.div`\r\n  position: relative;\r\n  width: 114px;\r\n  height: 114px;\r\n  border-radius: 10em;\r\n  background: #6c6c6c;\r\n  &::after {\r\n    content: '';\r\n    position: absolute;\r\n    width: 185.65px;\r\n    height: 93.5px;\r\n    top: 100px;\r\n    left: -35px;\r\n    border-bottom-right-radius: 10px;\r\n    border-bottom-left-radius: 10px;\r\n    border-top-left-radius: 5em;\r\n    border-top-right-radius: 5em;\r\n    background: #6c6c6c;\r\n  }\r\n`;\r\n\r\nexport { StyledAvatar, DefaultAvatar };\r\n","import React from 'react';\r\nimport { IAvatarProps } from './Avatar.types';\r\nimport { DefaultAvatar, StyledAvatar } from './Avatar.styles';\r\nconst Avatar = ({ src }: IAvatarProps) => {\r\n  return <StyledAvatar>{src ? <img src={src} alt=\"avatar\" /> : <DefaultAvatar />}</StyledAvatar>;\r\n};\r\n\r\nexport default Avatar;\r\n","import styled from 'styled-components';\r\nimport { IStyledButtonProps } from './Button.types';\r\n\r\nconst StyledButton = styled.button<IStyledButtonProps>`\r\n  width: 100%;\r\n  height: 50px;\r\n  border: none;\r\n  border-radius: 88px;\r\n  background: linear-gradient(91.2deg, #ffffff 0%, #f2f2f2 100%);\r\n  box-shadow: -2px -4px 12px #ffffff, 2px 4px 8px rgba(0, 0, 0, 0.2);\r\n  will-change: transform;\r\n  transition: transform 500ms ease;\r\n\r\n  font: bold normal 18px/21px Roboto, sans-serif;\r\n  text-align: center;\r\n  cursor: pointer;\r\n\r\n  &:hover {\r\n    background: linear-gradient(54deg, #f8f8f8 0%, #eae9e9 100%);\r\n  }\r\n\r\n  &:focus {\r\n    outline: none;\r\n    border: 1px solid #9e9e9e;\r\n  }\r\n\r\n  &:active {\r\n    background: linear-gradient(91.2deg, #ffffff 0%, #f2f2f2 100%);\r\n    box-shadow: inset -2px -4px 12px #ffffff, inset 2px 4px 8px rgba(0, 0, 0, 0.2);\r\n    border: none;\r\n  }\r\n\r\n  transform: ${props => props.isMove && 'translateY(60px)'};\r\n`;\r\n\r\nexport default StyledButton;\r\n","import React from 'react';\r\nimport StyledButton from './Button.styles';\r\nimport { IButtonProps } from './Button.types';\r\n\r\nconst Button = ({ content, onclickHandler, isMove }: IButtonProps) => {\r\n  return (\r\n    <StyledButton onClick={onclickHandler} isMove={isMove}>\r\n      {content}\r\n    </StyledButton>\r\n  );\r\n};\r\n\r\nexport default Button;\r\n","import styled from 'styled-components';\r\n\r\nconst StyledSentenceWord = styled.span`\r\n  font: normal normal 18px/21px Roboto, sans-serif;\r\n  border-bottom: 1px dashed #000000;\r\n  cursor: help;\r\n`;\r\n\r\nexport default StyledSentenceWord;\r\n","import React from 'react';\r\nimport { ISentenceWordProps } from './SentenceWord.types';\r\nimport StyledSentenceWord from './SentenceWord.styles';\r\nconst SentenceWord = ({ content }: ISentenceWordProps) => {\r\n  return <StyledSentenceWord>{content}</StyledSentenceWord>;\r\n};\r\n\r\nexport default React.memo(SentenceWord);\r\n","import styled from 'styled-components';\r\n\r\nconst StyledTitle = styled.h1`\r\n  font: normal normal 36px/42px Roboto, sans-serif;\r\n  color: #252525;\r\n  text-shadow: -2px -4px 3px #ffffff, 2px 4px 3px rgba(0, 0, 0, 0.25);\r\n`;\r\nexport default StyledTitle;\r\n","import { ITitleProps } from './Title.types';\r\nimport StyledTitle from './Title.styles';\r\n\r\nconst Title = ({ content }: ITitleProps) => {\r\n  return <StyledTitle>{content}</StyledTitle>;\r\n};\r\n\r\nexport default Title;\r\n","import styled from 'styled-components';\r\n\r\nconst StyledSentence = styled.div`\r\n  position: relative;\r\n  max-width: 200px;\r\n  max-height: 69px;\r\n  padding: 12px;\r\n  border: 2px solid #252525;\r\n  border-radius: 10px;\r\n`;\r\nconst SentenceTip = styled.span`\r\n  display: inline-block;\r\n  position: absolute;\r\n  width: 7px;\r\n  height: 15px;\r\n  top: 60%;\r\n  left: -7px;\r\n  background: white;\r\n  &::after {\r\n    content: '';\r\n    position: absolute;\r\n    width: 20.7px;\r\n    height: 1.5px;\r\n    top: 6.5px;\r\n    left: -11px;\r\n    border-radius: 17px;\r\n    background: black;\r\n    transform: rotate(133deg);\r\n  }\r\n\r\n  &::before {\r\n    content: '';\r\n    position: absolute;\r\n    height: 1.4px;\r\n    width: 15px;\r\n    top: 14px;\r\n    right: 0.1px;\r\n    border-radius: 20px;\r\n    background: black;\r\n  }\r\n`;\r\nconst SentenceList = styled.ul`\r\n  display: flex;\r\n  flex-flow: row wrap;\r\n  gap: 7px;\r\n  max-height: 70px;\r\n  margin: 0;\r\n  padding: 2px;\r\n  list-style-type: none;\r\n  overflow: auto;\r\n`;\r\n\r\nexport { SentenceList, SentenceTip, StyledSentence };\r\n","import React from 'react';\r\nimport { SentenceList, SentenceTip, StyledSentence } from './Sentence.styles';\r\nimport { SentencePropsType } from './Sentence.types';\r\n\r\nconst Sentence = ({ children }: SentencePropsType) => {\r\n  return (\r\n    <StyledSentence>\r\n      <SentenceTip />\r\n      <SentenceList>{children}</SentenceList>\r\n    </StyledSentence>\r\n  );\r\n};\r\n\r\nexport default Sentence;\r\n","const TRANSITION_TIME = 500;\r\nconst INITIAL_TRANSLATE_COORDS = { x: 0, y: 0 };\r\nconst INITIAL_SHIFT_COORDS = {\r\n  shiftX: 0,\r\n  shiftY: 0,\r\n  initialX: 0,\r\n  initialY: 0,\r\n};\r\nconst INITIAL_DRAGGABLE_ID = {\r\n  originId: 0,\r\n  wordId: 0,\r\n};\r\nexport { TRANSITION_TIME, INITIAL_SHIFT_COORDS, INITIAL_TRANSLATE_COORDS, INITIAL_DRAGGABLE_ID };\r\n","const locales = [\r\n  {\r\n    language: 'en', // words to translate\r\n    messages: {\r\n      q1: {\r\n        question: 'his name is jack and he is a pilot',\r\n      },\r\n    },\r\n  },\r\n\r\n  {\r\n    language: 'ru', // answers words\r\n    messages: {\r\n      q1: {\r\n        answers: 'пилот его и Джек он имя',\r\n        correct: 'его имя Джек и он пилот',\r\n      },\r\n    },\r\n  },\r\n];\r\n\r\nexport default locales;\r\n","import { IAnchor } from '../../atoms/Anchor/Anchor.types';\r\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\r\nimport { IOriginCoords } from './Quiz.types';\r\nimport { Translator } from '@eo-locale/core';\r\nimport locales from '../../locales';\r\n\r\nconst getCorrectWords = (language: 'ru' | 'en', target: 'answers' | 'correct', quizId: string): IWord[] => {\r\n  const words = new Translator(language, locales).translate(`${quizId}.${target}`);\r\n  return words.split(' ').map((text, index) => ({\r\n    text,\r\n    wordId: index,\r\n    originId: index,\r\n    from: 'waiting',\r\n  }));\r\n};\r\n\r\nconst getCorrectAnchors = (language: 'ru' | 'en', target: 'answers' | 'correct', quizId: string): IAnchor[] => {\r\n  const words = new Translator(language, locales).translate(`${quizId}.${target}`);\r\n  return words.split(' ').map((_, index) => ({\r\n    anchorId: index,\r\n    isHidden: target === 'answers',\r\n    answerId: null,\r\n    isPrepared: false,\r\n  }));\r\n};\r\n\r\nconst getCorrectText = (quizId: string) => {\r\n  return new Translator('ru', locales).getMessageById(`${quizId}.correct`) as string;\r\n};\r\n\r\nconst getQuestionText = (quizId: string) => {\r\n  return new Translator('en', locales).getMessageById(`${quizId}.question`) as string;\r\n};\r\n\r\nconst getConvertedAnchors = <R extends IAnchor[] | { [key: string]: IAnchor }>(\r\n  anchors: R\r\n): R extends IAnchor[] ? { [key: string]: IAnchor } : IAnchor[] =>\r\n  Array.isArray(anchors)\r\n    ? anchors.reduce((acc, anchor) => ({ ...acc, [anchor.anchorId]: { ...anchor } }), {})\r\n    : Object.values(anchors);\r\n\r\nconst getConvertedWords = (words: IWord[]): { [key: string]: IWord } =>\r\n  words.reduce((acc, word) => ({ ...acc, [word.wordId]: { ...word } }), {});\r\n\r\nconst getAnchorsDomList = <T extends HTMLElement>(anchorsDomRoot: T): T[] =>\r\n  (Array.from(anchorsDomRoot.children) as T[]).reduce(\r\n    (anchors: T[], anchor) =>\r\n      anchor.children.length !== 0 && !anchor.children[0].matches('.answer-word')\r\n        ? [...anchors, ...getAnchorsDomList(anchor)]\r\n        : [...anchors, anchor],\r\n    []\r\n  );\r\n\r\nconst calcOriginCoords = (\r\n  root: HTMLElement,\r\n  idBeforeDraggableElem: number[],\r\n  settings?: { direction: 'right' | 'left' }\r\n) => {\r\n  const { direction } = settings ?? { direction: 'left' }; //default settings\r\n  const coords = getAnchorsDomCoords(root);\r\n  return idBeforeDraggableElem.reduce(\r\n    (originCoords: IOriginCoords, id) => ({\r\n      ...originCoords,\r\n      [id]: {\r\n        x: coords[direction === 'right' ? (coords.length === id + 1 ? id : id + 1) : id - 1].x - coords[id].x, // overfloow\r\n        y: coords[direction === 'right' ? (coords.length === id + 1 ? id : id + 1) : id - 1].y - coords[id].y, // overfloow\r\n      },\r\n    }),\r\n    {}\r\n  );\r\n};\r\n\r\nconst getAnchorsDomCoords = (anchorsDomRoot: HTMLElement) =>\r\n  getAnchorsDomList(anchorsDomRoot).map(anchor => ({\r\n    x: anchor.getBoundingClientRect().x,\r\n    y: anchor.getBoundingClientRect().y,\r\n  }));\r\n\r\nconst getIdBeforeDraggableElem = (\r\n  words: { wordsList: IWord[]; wordsArea: 'waiting' | 'answers' },\r\n  draggableElem: IWord,\r\n  action: 'put' | 'take'\r\n) => {\r\n  const { wordsList, wordsArea } = words;\r\n  const isGap = (word: IWord) => {\r\n    if (word.wordId - shiftedId > 1) {\r\n      isBlocked = true;\r\n      return false;\r\n    } else {\r\n      shiftedId += 1;\r\n      return true;\r\n    }\r\n  };\r\n\r\n  const isAnchorBusy =\r\n    draggableElem.from === 'waiting' ? true : wordsList.find(word => word.wordId === draggableElem.originId);\r\n  let isBlocked = isAnchorBusy ? false : true;\r\n  let shiftedId = action === 'put' ? draggableElem.originId : draggableElem.wordId;\r\n  const result = wordsList\r\n    .filter(word => {\r\n      if (wordsArea === 'waiting') {\r\n        if (isBlocked) return false;\r\n        if (action === 'put') {\r\n          if (word.wordId >= draggableElem.originId) {\r\n            return isGap(word);\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          if (word.wordId > draggableElem.wordId) {\r\n            return isGap(word);\r\n          } else {\r\n            return false;\r\n          }\r\n        }\r\n      } else {\r\n        return word.wordId > draggableElem.wordId;\r\n      }\r\n    })\r\n    .map(word => word.wordId);\r\n  return result;\r\n};\r\n\r\nconst getUpdatedAnswersAnchors = (\r\n  anchors: IAnchor[],\r\n  action: 'setBusy' | 'delBusy' | 'prepare' | 'disprepare' | 'prepareLast'\r\n) => {\r\n  const convertedAnchors = getConvertedAnchors(anchors);\r\n  let targetAnchor;\r\n  switch (action) {\r\n    case 'setBusy': {\r\n      targetAnchor = [...anchors].reverse().find(anchor => anchor.isPrepared);\r\n      break;\r\n    }\r\n    case 'delBusy': {\r\n      targetAnchor = [...anchors].reverse().find(anchor => anchor.answerId !== null);\r\n      break;\r\n    }\r\n    case 'disprepare': {\r\n      targetAnchor = [...anchors].reverse().find(anchor => anchor.isPrepared && anchor.answerId === null);\r\n      break;\r\n    }\r\n    case 'prepareLast': {\r\n      targetAnchor = [...anchors].reverse().find(anchor => anchor.answerId !== null) as IAnchor;\r\n      break;\r\n    }\r\n    default: {\r\n      targetAnchor = anchors.find(anchor => anchor.answerId === null);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // check undefined\r\n  if (targetAnchor) {\r\n    convertedAnchors[targetAnchor.anchorId] = {\r\n      ...targetAnchor,\r\n      isPrepared: action === 'prepare' || action === 'prepareLast',\r\n      answerId: action === 'setBusy' || action === 'prepareLast' ? targetAnchor.anchorId : null,\r\n    };\r\n  }\r\n\r\n  return getConvertedAnchors(convertedAnchors);\r\n};\r\n\r\nconst getShiftedWords = (\r\n  words: IWord[],\r\n  dragId: number,\r\n  idBeforeDraggableElem: number[],\r\n  settings: { elementAction: 'remove' | 'add'; directionShift: 'left' | 'right' }\r\n) => {\r\n  const { elementAction, directionShift } = settings;\r\n\r\n  const correctWords = elementAction === 'add' ? words : words.filter(word => word.wordId !== dragId);\r\n  return correctWords.map(word =>\r\n    idBeforeDraggableElem.includes(word.wordId)\r\n      ? {\r\n          ...word,\r\n          wordId:\r\n            directionShift === 'right'\r\n              ? words.length === word.wordId // overfloow\r\n                ? word.wordId\r\n                : word.wordId + 1\r\n              : word.wordId - 1,\r\n        }\r\n      : word\r\n  );\r\n};\r\n\r\nexport {\r\n  calcOriginCoords,\r\n  getAnchorsDomCoords,\r\n  getIdBeforeDraggableElem,\r\n  getShiftedWords,\r\n  getUpdatedAnswersAnchors,\r\n  getConvertedWords,\r\n  getAnchorsDomList,\r\n  getConvertedAnchors,\r\n  getCorrectWords,\r\n  getCorrectAnchors,\r\n  getCorrectText,\r\n  getQuestionText,\r\n};\r\n","import styled from 'styled-components';\r\nimport { IMessageTextProps, IStyledMessagepProps } from './Message.types';\r\nconst errorColor = '#ff0000';\r\nconst successColor = 'rgb(133, 238, 203)';\r\n\r\nconst StyledMessage = styled.div<IStyledMessagepProps>`\r\n  position: relative;\r\n  will-change: opacity;\r\n  opacity: ${props => (props.isShow ? 1 : 0)};\r\n  transition: opacity 2000ms ease;\r\n  width: 50%;\r\n`;\r\n\r\nconst MessageText = styled.span<IMessageTextProps>`\r\n  position: absolute;\r\n  left: 0;\r\n  right: 0;\r\n  position: absolute;\r\n  text-align: center;\r\n  font: normal normal 24px/28px Roboto, sans-serif;\r\n  color: ${props => (props.isError ? errorColor : successColor)};\r\n  text-shadow: -1px -2px 2px #ffffff, 1px 2px 2px rgba(91, 13, 13, 0.5);\r\n`;\r\n\r\nexport { StyledMessage, MessageText };\r\n","import React from 'react';\r\nimport { MessageText, StyledMessage } from './Message.styles';\r\nimport { IMessageProps } from './Message.types';\r\n\r\nconst Message = ({ content, isError }: IMessageProps) => {\r\n  const isShow = content ? true : false;\r\n  return (\r\n    <StyledMessage isShow={isShow}>\r\n      <MessageText isError={isError}>{content}</MessageText>\r\n    </StyledMessage>\r\n  );\r\n};\r\n\r\nexport default Message;\r\n","import styled from 'styled-components';\r\n\r\nconst StyledAnswerWord = styled.span`\r\n  width: 70px;\r\n  height: 30px;\r\n  background: #ffffff;\r\n  border: 1px solid #c9c9c9;\r\n  box-shadow: 0px 8px 4px -6px rgba(0, 0, 0, 0.25);\r\n  border-radius: 13px;\r\n  display: inline-block;\r\n  will-change: transform;\r\n  touch-action: none;\r\n\r\n  font: normal normal 16px/25px Roboto;\r\n  color: #000000;\r\n  text-align: center;\r\n  user-select: none;\r\n  cursor: grab;\r\n  &:active {\r\n    cursor: grabbing;\r\n  }\r\n`;\r\n\r\nexport { StyledAnswerWord };\r\n","import React from 'react';\r\nimport { StyledAnswerWord } from './AnswerWord.styles';\r\nimport { IAnswerWordProps } from './AnswerWord.types';\r\nconst AnswerWord = ({ content, style, onMouseDown }: IAnswerWordProps) => {\r\n  return (\r\n    <StyledAnswerWord\r\n      style={style}\r\n      className={'answer-word'}\r\n      onMouseDown={onMouseDown ?? null}\r\n      onTouchStart={onMouseDown ?? null}\r\n    >\r\n      {content}\r\n    </StyledAnswerWord>\r\n  );\r\n};\r\n\r\nexport default AnswerWord;\r\n","import React, { Fragment, useCallback, useEffect, useMemo, useRef, useState } from 'react';\r\nimport { INITIAL_SHIFT_COORDS, INITIAL_TRANSLATE_COORDS, TRANSITION_TIME } from '../../settings/constants';\r\nimport { DraggablePropsType, GetBellowElement } from './Draggable.types';\r\n\r\nconst Draggable = ({\r\n  draggableElemInfo,\r\n  children,\r\n  isTransitioned,\r\n  originCoords,\r\n  dragStartHandler,\r\n  dragMoveHandler,\r\n  dragEndHandler,\r\n  isBlockAnimaton,\r\n}: DraggablePropsType) => {\r\n  // ANIMATION CONTROL------------------------------------------------------------\r\n  const [isDragStart, setDragStart] = useState(false);\r\n  const [draggableElem, setDraggableElem] = useState<HTMLElement | null>(null);\r\n\r\n  // SETTINGS FOR DETERMINING THE CURRENT ZONE (bellow element)-------------------\r\n  const inDropArea = useRef(false);\r\n  const currentArea = useRef(draggableElemInfo.from === 'waiting' ? 'waitingArea' : 'answersArea');\r\n  const prevDropArea = useRef(draggableElemInfo.from === 'waiting' ? 'waitingArea' : 'answersArea');\r\n  const debounce = useRef<string>();\r\n\r\n  // TRANSLATE COORDS-------------------------------------------------------------\r\n  const [translateCoords, setTranslateCoords] = useState(INITIAL_TRANSLATE_COORDS);\r\n  const [shiftCoords, setShiftCoords] = useState(INITIAL_SHIFT_COORDS);\r\n\r\n  // HELPERS FUNCTIONS---------------------------------------------------\r\n  const getBellowElemDataAttr = (bellowElem: HTMLElement | null) => {\r\n    if (bellowElem) {\r\n      return Object.keys(bellowElem.dataset).length !== 0\r\n        ? bellowElem.dataset.dropname\r\n          ? (bellowElem.dataset.dropname as string)\r\n          : (bellowElem.dataset.anchor as string)\r\n        : null;\r\n    } else {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const defineElemFromPoint = (selector: string | string[], coords: [x: number, y: number]) =>\r\n    Array.isArray(selector)\r\n      ? selector.reduce(\r\n          (elem: HTMLElement | null, s) =>\r\n            elem === null && document.elementFromPoint(...coords) !== null\r\n              ? (document.elementFromPoint(...coords) as HTMLElement).closest(s)\r\n                ? (document.elementFromPoint(...coords) as HTMLElement).closest(s)\r\n                : elem\r\n              : elem,\r\n          null\r\n        )\r\n      : ((document.elementFromPoint(...coords) as HTMLElement).closest(selector) as HTMLElement);\r\n\r\n  const setCurrentArea = useCallback((dropAreaName: string | null) => {\r\n    if (inDropArea.current && dropAreaName) {\r\n      if (prevDropArea.current === dropAreaName) {\r\n        return dropAreaName;\r\n      } else {\r\n        prevDropArea.current = dropAreaName;\r\n        return dropAreaName;\r\n      }\r\n    } else {\r\n      return `out-${prevDropArea.current}`;\r\n    }\r\n  }, []);\r\n\r\n  const isDraggableElemInDropArea = useCallback(\r\n    (bellowElem: null | HTMLElement) =>\r\n      // если курсор выходит за viewport, то bellowElem = null\r\n      bellowElem\r\n        ? bellowElem.dataset.dropname || bellowElem.matches('[data-anchor=\"waitingAnchor\"]')\r\n          ? true\r\n          : false\r\n        : false,\r\n    []\r\n  );\r\n\r\n  const getBellowElement: GetBellowElement = useCallback((target, x, y) => {\r\n    const matchList = ['[data-anchor=\"waitingAnchor\"]', '[data-dropname]'];\r\n\r\n    // target.classList.add('hidden');\r\n    target.style.visibility = 'hidden';\r\n    const bellowElem = defineElemFromPoint(matchList, [x, y]);\r\n    target.style.visibility = '';\r\n\r\n    return bellowElem ?? (document.elementFromPoint(x, y) as HTMLElement);\r\n  }, []);\r\n\r\n  const makeDraggableElement = () =>\r\n    React.Children.map(children, item => {\r\n      return React.cloneElement(item, {\r\n        ...item.props,\r\n        style,\r\n        onMouseDown: isBlockAnimaton ? null : dragStart,\r\n        onTouchStart: isBlockAnimaton ? null : dragStart,\r\n      });\r\n    });\r\n\r\n  // HANDLER FUNCTIONS---------------------------------------------------\r\n  const dragStart = useCallback(\r\n    (ev: React.MouseEvent<HTMLSpanElement> | React.TouchEvent<HTMLSpanElement>) => {\r\n      let shiftCoords =\r\n        ev.nativeEvent instanceof MouseEvent\r\n          ? [(ev as React.MouseEvent).clientX, (ev as React.MouseEvent).clientY]\r\n          : [0, 0];\r\n\r\n      const draggableElem = ev.target as HTMLSpanElement;\r\n      setDragStart(true);\r\n      setDraggableElem(draggableElem);\r\n\r\n      setShiftCoords(prevState => ({\r\n        ...prevState,\r\n        shiftX: shiftCoords[0] - draggableElem.getBoundingClientRect().x,\r\n        shiftY: shiftCoords[1] - draggableElem.getBoundingClientRect().y,\r\n        initialX: draggableElem.getBoundingClientRect().x,\r\n        initialY: draggableElem.getBoundingClientRect().y,\r\n      }));\r\n\r\n      dragStartHandler({\r\n        from: draggableElemInfo.from,\r\n        dragId: draggableElemInfo.wordId,\r\n      });\r\n      draggableElem.ondragstart = () => false;\r\n    },\r\n    [dragStartHandler, draggableElemInfo]\r\n  );\r\n\r\n  const dragMove = useCallback(\r\n    (ev: MouseEvent | TouchEvent) => {\r\n      const { clientX, clientY, target } = ev instanceof TouchEvent ? ev.touches[0] : ev;\r\n      const touchShifteCoords = [40, 20];\r\n      if (ev instanceof TouchEvent) ev.preventDefault();\r\n\r\n      const bellowElem = getBellowElement(target as HTMLElement, clientX, clientY);\r\n      inDropArea.current = isDraggableElemInDropArea(bellowElem);\r\n      const currentAreaName = setCurrentArea(getBellowElemDataAttr(bellowElem));\r\n\r\n      if (currentAreaName !== debounce.current) {\r\n        debounce.current = currentAreaName;\r\n        currentArea.current = currentAreaName;\r\n        dragMoveHandler({\r\n          from: draggableElemInfo.from,\r\n          currentArea: currentArea.current as 'out-answersArea' | 'answersArea',\r\n        });\r\n      }\r\n\r\n      setTranslateCoords(prevState => ({\r\n        ...prevState,\r\n        x:\r\n          ev instanceof TouchEvent\r\n            ? clientX - shiftCoords.initialX - touchShifteCoords[0]\r\n            : clientX - shiftCoords.initialX - shiftCoords.shiftX,\r\n        y:\r\n          ev instanceof TouchEvent\r\n            ? clientY - shiftCoords.initialY - touchShifteCoords[1]\r\n            : clientY - shiftCoords.initialY - shiftCoords.shiftY,\r\n      }));\r\n      if (bellowElem) bellowElem.ondragstart = () => false;\r\n    },\r\n    [\r\n      dragMoveHandler,\r\n      draggableElemInfo.from,\r\n      getBellowElement,\r\n      isDraggableElemInDropArea,\r\n      setCurrentArea,\r\n      shiftCoords.initialX,\r\n      shiftCoords.initialY,\r\n      shiftCoords.shiftX,\r\n      shiftCoords.shiftY,\r\n    ]\r\n  );\r\n\r\n  const dragEnd = useCallback(\r\n    (ev: MouseEvent | TouchEvent) => {\r\n      const { clientX, clientY, target } = ev instanceof TouchEvent ? ev.changedTouches[0] : ev;\r\n\r\n      draggableElem?.classList.remove('draggable');\r\n      const bellowElement = getBellowElement(target as HTMLElement, clientX, clientY);\r\n      setDragStart(false);\r\n      setTranslateCoords(INITIAL_TRANSLATE_COORDS);\r\n\r\n      dragEndHandler({\r\n        from: draggableElemInfo.from,\r\n        originId: draggableElemInfo.originId,\r\n        dragId: draggableElemInfo.wordId,\r\n        currentArea: currentArea.current as 'waitingArea' | 'answersArea' | 'waitingAnchor',\r\n        anchorId: bellowElement\r\n          ? bellowElement.dataset.id || bellowElement.dataset.id === '0'\r\n            ? Number(bellowElement.dataset.id)\r\n            : null\r\n          : null,\r\n      });\r\n    },\r\n    [\r\n      dragEndHandler,\r\n      draggableElem?.classList,\r\n      draggableElemInfo.from,\r\n      draggableElemInfo.originId,\r\n      draggableElemInfo.wordId,\r\n      getBellowElement,\r\n    ]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (isDragStart && !isBlockAnimaton) {\r\n      window.addEventListener('mousemove', dragMove);\r\n      window.addEventListener('mouseup', dragEnd);\r\n      window.addEventListener('touchmove', dragMove, false);\r\n      window.addEventListener('touchend', dragEnd);\r\n    } else {\r\n      window.removeEventListener('mousemove', dragMove);\r\n      window.removeEventListener('mouseup', dragEnd);\r\n      window.removeEventListener('touchmove', dragMove);\r\n      window.removeEventListener('touchend', dragEnd);\r\n    }\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', dragMove);\r\n      window.removeEventListener('mouseup', dragEnd);\r\n      window.removeEventListener('touchmove', dragMove);\r\n      window.removeEventListener('touchend', dragEnd);\r\n    };\r\n  }, [dragEnd, dragMove, isBlockAnimaton, isDragStart]);\r\n\r\n  const style = useMemo(\r\n    () => ({\r\n      willChange: 'transform',\r\n      transform: isDragStart\r\n        ? `translate(\r\n      ${translateCoords.x + originCoords.x}px, \r\n      ${translateCoords.y + originCoords.y}px)`\r\n        : `translate(${originCoords.x}px, ${originCoords.y}px)`,\r\n      transition: isDragStart || isTransitioned ? '' : `transform ${TRANSITION_TIME}ms ease`,\r\n      zIndex: isDragStart && 999,\r\n      position: isDragStart && 'absolute',\r\n      background: isDragStart && '#e9e8e8',\r\n    }),\r\n    [isDragStart, isTransitioned, originCoords.x, originCoords.y, translateCoords.x, translateCoords.y]\r\n  );\r\n\r\n  return <Fragment>{makeDraggableElement()}</Fragment>;\r\n};\r\n\r\nexport default React.memo(Draggable);\r\n","import styled from 'styled-components';\r\nimport { IStyledAnchorProps } from './Anchor.types';\r\nconst preparedColor = 'rgba(224, 224, 224, 0.452)';\r\nconst showColor = '#ececec';\r\n\r\nconst StyledAnchor = styled.li<IStyledAnchorProps>`\r\n  will-change: background-color;\r\n  transition: opacity 200ms ease, background-color 200ms ease;\r\n  opacity: 1;\r\n  width: 70px;\r\n  height: 30px;\r\n  border-radius: 13px;\r\n  display: inline-block;\r\n  background: ${props => !props.isHidden && showColor};\r\n  background: ${props => props.isPrepared && preparedColor};\r\n  box-shadow: ${props => !props.isHidden && 'inset 0px 8px 4px -6px rgba(0, 0, 0, 0.25)'};\r\n`;\r\n\r\nexport { StyledAnchor };\r\n","import React from 'react';\r\nimport { StyledAnchor } from './Anchor.styles';\r\nimport { IAnchorProps } from './Anchor.types';\r\nconst Anchor = ({ children, isHidden, isPrepared, isDataAttr, id }: IAnchorProps) => {\r\n  return (\r\n    <StyledAnchor\r\n      isHidden={!!isHidden}\r\n      isPrepared={!!isPrepared}\r\n      data-anchor={isDataAttr ? 'waitingAnchor' : 'answerAnchor'}\r\n      data-id={isHidden ? null : id}\r\n    >\r\n      {children}\r\n    </StyledAnchor>\r\n  );\r\n};\r\n\r\nexport default React.memo(Anchor);\r\n","import styled from 'styled-components';\r\n\r\nconst StyledDropArea = styled.div`\r\n  display: flex;\r\n  flex-flow: row wrap;\r\n  max-width: 470px;\r\n\r\n  &[data-dropname='waitingArea'] {\r\n    gap: 10px;\r\n    padding: 0;\r\n    margin: 0;\r\n  }\r\n`;\r\n\r\nconst Wrapper = styled.div`\r\n  display: flex;\r\n  flex-flow: row wrap;\r\n  flex-grow: 1;\r\n  gap: 10px;\r\n  border-top: 2px solid #cecccc;\r\n  padding: 10px 0px;\r\n  margin: 0;\r\n  list-style-type: none;\r\n\r\n  &:last-child {\r\n    justify-content: flex-start;\r\n    border-bottom: 2px solid #cecccc;\r\n  }\r\n`;\r\n\r\nexport { Wrapper, StyledDropArea };\r\n","import React, { forwardRef } from 'react';\r\nimport AnswerWord from '../../atoms/AnswerWord/AnswerWord';\r\nimport { IDropAreaProps } from './DropArea.types';\r\nimport Draggable from '../../libs/Draggable/Draggable';\r\nimport Anchor from '../../atoms/Anchor/Anchor';\r\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\r\nimport { IAnchor } from '../../atoms/Anchor/Anchor.types';\r\nimport { StyledDropArea, Wrapper } from './DropArea.styles';\r\n\r\nconst DropArea = forwardRef<any, IDropAreaProps>(\r\n  (\r\n    {\r\n      areaName,\r\n      anchors,\r\n      words,\r\n      originCoords,\r\n      dragStartHandler,\r\n      dragMoveHandler,\r\n      dragEndHandler,\r\n      isTransitioned,\r\n      isBlockAnimaton,\r\n    },\r\n    ref\r\n  ) => {\r\n    const preparedWords: { [key: string]: IWord } = words.reduce(\r\n      (acc, item) => ({ ...acc, [item.wordId]: { ...item } }),\r\n      {}\r\n    );\r\n    const createWord = (anchor: IAnchor, isDataAttribute: boolean = false) => (\r\n      <Anchor\r\n        key={anchor.anchorId}\r\n        isHidden={anchor.isHidden}\r\n        isPrepared={anchor.isPrepared}\r\n        isDataAttr={isDataAttribute}\r\n        id={anchor.anchorId}\r\n      >\r\n        {preparedWords[anchor.anchorId] && (\r\n          <Draggable\r\n            draggableElemInfo={{ ...preparedWords[anchor.anchorId] }}\r\n            isTransitioned={isTransitioned}\r\n            originCoords={originCoords[anchor.anchorId] ?? { x: 0, y: 0 }}\r\n            dragStartHandler={dragStartHandler}\r\n            dragMoveHandler={dragMoveHandler}\r\n            dragEndHandler={dragEndHandler}\r\n            isBlockAnimaton={isBlockAnimaton}\r\n          >\r\n            <AnswerWord content={preparedWords[anchor.anchorId].text} key={preparedWords[anchor.anchorId].wordId} />\r\n          </Draggable>\r\n        )}\r\n      </Anchor>\r\n    );\r\n\r\n    // [words] => [[words],[words],[wrods]...]\r\n    const getPreparedAnchors = () =>\r\n      [...Array(Math.ceil(anchors.length / 6)).keys()].map(row => anchors.slice(row * 6, (row + 1) * 6));\r\n\r\n    const createAnchors = () =>\r\n      getPreparedAnchors().map((anchorWrapper, rowId) => (\r\n        <Wrapper key={rowId}>{anchorWrapper.map(anchor => createWord(anchor))}</Wrapper>\r\n      ));\r\n\r\n    return areaName === 'answersArea' ? (\r\n      <StyledDropArea data-dropname={areaName} ref={ref}>\r\n        {createAnchors()}\r\n      </StyledDropArea>\r\n    ) : (\r\n      <StyledDropArea data-dropname={areaName} ref={ref}>\r\n        {anchors.map(anchor => createWord(anchor, true))}\r\n      </StyledDropArea>\r\n    );\r\n  }\r\n);\r\n\r\nexport default DropArea;\r\n","import styled from 'styled-components';\r\n\r\nconst StyledQuiz = styled.div`\r\n  max-width: 472px;\r\n  margin: 0 auto;\r\n  display: flex;\r\n  flex-flow: column nowrap;\r\n  align-items: center;\r\n  padding: 0px 0px 30px 0;\r\n`;\r\nconst QuizInfo = styled.div`\r\n  margin-bottom: 20px;\r\n  display: flex;\r\n`;\r\nconst QuizAnswersWrapper = styled.div`\r\n  margin-bottom: 50px;\r\n`;\r\n\r\nconst QuizWaitingWrapper = styled.div`\r\n  margin-bottom: 25px;\r\n`;\r\n\r\nconst QuizButtonWrapper = styled.div`\r\n  max-width: 320px;\r\n  width: 100%;\r\n`;\r\nexport { StyledQuiz, QuizInfo, QuizAnswersWrapper, QuizWaitingWrapper, QuizButtonWrapper };\r\n","import React, { RefObject, useCallback, useEffect, useRef, useState } from 'react';\r\nimport Avatar from '../../atoms/Avatar/Avatar';\r\nimport Button from '../../atoms/Button/Button';\r\nimport SentenceWord from '../../atoms/SentenceWord/SentenceWord';\r\nimport Title from '../../atoms/Title/Title';\r\nimport Sentence from '../../molecules/Sentence/Sentence';\r\nimport { INITIAL_DRAGGABLE_ID, TRANSITION_TIME } from '../../settings/constants';\r\nimport { IAnchor } from '../../atoms/Anchor/Anchor.types';\r\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\r\nimport {\r\n  calcOriginCoords,\r\n  getAnchorsDomCoords,\r\n  getConvertedWords,\r\n  getCorrectAnchors,\r\n  getCorrectWords,\r\n  getIdBeforeDraggableElem,\r\n  getShiftedWords,\r\n  getUpdatedAnswersAnchors,\r\n  getAnchorsDomList,\r\n  getCorrectText,\r\n  getQuestionText,\r\n} from './Quiz.helpers';\r\nimport Message from '../../atoms/Message/Message';\r\nimport {\r\n  IOriginCoords,\r\n  IQuizProps,\r\n  TDragEndHandler,\r\n  TDraggableId,\r\n  TDragMoveHandler,\r\n  TDragStartHandler,\r\n} from './Quiz.types';\r\nimport DropArea from '../../molecules/DropArea/DropArea';\r\nimport { QuizAnswersWrapper, QuizButtonWrapper, QuizInfo, QuizWaitingWrapper, StyledQuiz } from './Quiz.styles';\r\nconst Quiz = ({ quizId }: IQuizProps) => {\r\n  // result-info----------------------------------------------------------\r\n  const [resultMessage, setResultMessage] = useState<string | null>(null);\r\n  const [isError, setError] = useState<boolean | null>(null);\r\n\r\n  // animation-data------------------------------------------------------\r\n  const [isBlockAnimaton, setBlockAnimation] = useState(false);\r\n  const [dragEndEvent, setDragEndEvent] = useState<string>('');\r\n  const waitingRef = useRef() as RefObject<HTMLUListElement>;\r\n  const answersRef = useRef() as RefObject<HTMLDivElement>;\r\n  const isTransitioned = useRef(false);\r\n  const [draggableId, setDraggableId] = useState<TDraggableId>(INITIAL_DRAGGABLE_ID);\r\n\r\n  // origin-coords-------------------------------------------------------\r\n  const [waitingOriginCoords, setWaitingOriginCoords] = useState<IOriginCoords>({});\r\n  const [answersOriginCoords, setAnswersOriginCoords] = useState<IOriginCoords>({});\r\n  // words---------------------------------------------------------------\r\n  const [waitingWords, setWaitingWords] = useState<IWord[]>(getCorrectWords('ru', 'answers', quizId));\r\n  const [answersWords, setAnswersWords] = useState<IWord[]>([]);\r\n  // anchors-------------------------------------------------------------\r\n  const [answersAnchors, setAnswersAnchors] = useState(getCorrectAnchors('ru', 'answers', quizId));\r\n\r\n  // HELPER FUNCTIONS---------------------------------------------\r\n  const getNewOriginCoords = useCallback(\r\n    (target: 'waiting' | 'answers', dragId: number): IOriginCoords => {\r\n      const prevOriginCoords = target === 'waiting' ? waitingOriginCoords : answersOriginCoords;\r\n      const root = target === 'waiting' ? (waitingRef.current as HTMLElement) : (answersRef.current as HTMLElement);\r\n      const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n        {\r\n          wordsList: target === 'waiting' ? waitingWords : answersWords,\r\n          wordsArea: target,\r\n        },\r\n        getConvertedWords(target === 'waiting' ? waitingWords : answersWords)[dragId],\r\n        'take'\r\n      );\r\n      const calculatedOriginCoords = calcOriginCoords(root, idBeforeDraggableElem);\r\n      return {\r\n        ...prevOriginCoords,\r\n        ...calculatedOriginCoords,\r\n      };\r\n    },\r\n    [answersOriginCoords, answersWords, waitingOriginCoords, waitingWords]\r\n  );\r\n\r\n  const getAnswerPreparedAnchor = useCallback(\r\n    () => [...answersAnchors].reverse().find(anchor => anchor.isPrepared) as IAnchor,\r\n    [answersAnchors]\r\n  );\r\n\r\n  const getEmptyAnswerAnchor = (anchors: IAnchor[]) => anchors.find(anchor => anchor.answerId === null) as IAnchor;\r\n\r\n  const isTargetWaitingAnchorBusy = (currentArea: string, anchorId: number) =>\r\n    currentArea === 'waitingAnchor' && getAnchorsDomList(waitingRef.current as HTMLUListElement)[anchorId].children[0];\r\n\r\n  const resetOriginCoords = (time: number = 0) => {\r\n    setAnswersOriginCoords({});\r\n    setWaitingOriginCoords({});\r\n    setTimeout(() => setBlockAnimation(false), time);\r\n  };\r\n\r\n  const translateDragElemFromPending = useCallback(\r\n    (params: { anchorId: number; dragId: number }) => {\r\n      const { anchorId, dragId } = params;\r\n      const targetAnchorCoords = getAnchorsDomCoords(answersRef.current as HTMLElement)[anchorId];\r\n      const draggableElemCoords = getAnchorsDomCoords(waitingRef.current as HTMLElement)[dragId];\r\n      setWaitingOriginCoords({\r\n        ...waitingOriginCoords,\r\n        [dragId]: {\r\n          x: targetAnchorCoords.x - draggableElemCoords.x,\r\n          y: targetAnchorCoords.y - draggableElemCoords.y,\r\n        },\r\n      });\r\n    },\r\n    [waitingOriginCoords]\r\n  );\r\n\r\n  const translateDragElemFromAnswers = useCallback(\r\n    (\r\n      params: { dragId: number; anchorId: number },\r\n      anchorsRoot: HTMLDivElement | HTMLUListElement = waitingRef.current as HTMLUListElement\r\n    ) => {\r\n      const { dragId, anchorId } = params;\r\n      const draggableElemCoords = getAnchorsDomCoords(answersRef.current as HTMLElement)[dragId];\r\n      const targetAnchorCoords = getAnchorsDomCoords(anchorsRoot)[anchorId];\r\n      setAnswersOriginCoords({\r\n        ...answersOriginCoords,\r\n        [dragId]: {\r\n          x: targetAnchorCoords.x - draggableElemCoords.x,\r\n          y: targetAnchorCoords.y - draggableElemCoords.y,\r\n        },\r\n      });\r\n    },\r\n    [answersOriginCoords]\r\n  );\r\n\r\n  const translateWaitingWords = useCallback(\r\n    (dragId: number) => {\r\n      const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n        { wordsList: waitingWords, wordsArea: 'waiting' },\r\n        getConvertedWords(answersWords)[dragId],\r\n        'put'\r\n      );\r\n\r\n      setWaitingOriginCoords({\r\n        ...waitingOriginCoords,\r\n        ...calcOriginCoords(waitingRef.current as HTMLElement, idBeforeDraggableElem, { direction: 'right' }),\r\n      });\r\n    },\r\n    [answersWords, waitingOriginCoords, waitingWords]\r\n  );\r\n\r\n  // HANDLER FUNCTIONS---------------------------------------------\r\n  const checkAnswerHandler = useCallback(() => {\r\n    const correctText = getCorrectText(quizId);\r\n    const answersText = answersWords.map(word => word.text).join(' ');\r\n\r\n    if (correctText.localeCompare(answersText) === 0) {\r\n      setResultMessage('is complete!!!');\r\n    } else {\r\n      setError(true);\r\n      setResultMessage('something wrong');\r\n    }\r\n  }, [answersWords, quizId]);\r\n\r\n  const dragStartHandler: TDragStartHandler = useCallback(\r\n    ({ dragId, from }) => {\r\n      isTransitioned.current = false; // enable transition\r\n      setResultMessage(null);\r\n      setError(null);\r\n      if (from === 'waiting') {\r\n        setWaitingOriginCoords(getNewOriginCoords('waiting', dragId));\r\n      } else {\r\n        setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'prepareLast'));\r\n        setAnswersOriginCoords(getNewOriginCoords('answers', dragId));\r\n      }\r\n    },\r\n    [answersAnchors, getNewOriginCoords]\r\n  );\r\n\r\n  const dragMoveHandler: TDragMoveHandler = useCallback(\r\n    ({ from, currentArea }) => {\r\n      if (from === 'waiting') {\r\n        if (currentArea === 'answersArea') setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'prepare'));\r\n        if (currentArea === 'out-answersArea') {\r\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'disprepare'));\r\n        }\r\n      }\r\n    },\r\n    [answersAnchors]\r\n  );\r\n\r\n  const dragEndHandler: TDragEndHandler = useCallback(\r\n    ({ dragId, from, currentArea, originId, anchorId }) => {\r\n      setBlockAnimation(true); // disable handlers\r\n      if (from === 'waiting') {\r\n        if (currentArea === 'answersArea') {\r\n          // ANIMATION-----------------------------------------\r\n          translateDragElemFromPending({ anchorId: getEmptyAnswerAnchor(answersAnchors).anchorId, dragId });\r\n          setDraggableId({ originId, wordId: dragId });\r\n          setDragEndEvent('waiting-answers');\r\n        } else {\r\n          resetOriginCoords(100);\r\n        }\r\n      }\r\n\r\n      if (from === 'answers') {\r\n        const correctCurrentArea = isTargetWaitingAnchorBusy(currentArea, anchorId as number)\r\n          ? 'waitingArea'\r\n          : currentArea;\r\n        if (correctCurrentArea === 'waitingArea') {\r\n          // translate drag elem to pending\r\n          translateDragElemFromAnswers({ dragId, anchorId: originId });\r\n\r\n          // translate pending words\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            { wordsList: waitingWords, wordsArea: 'waiting' },\r\n            getConvertedWords(answersWords)[dragId],\r\n            'put'\r\n          );\r\n          setWaitingOriginCoords({\r\n            ...waitingOriginCoords,\r\n            ...calcOriginCoords(waitingRef.current as HTMLElement, idBeforeDraggableElem, { direction: 'right' }),\r\n          });\r\n\r\n          //UPDATE STATE----------------------------------\r\n          setDraggableId({ originId, wordId: dragId });\r\n          setDragEndEvent('answers-waiting');\r\n        } else if (correctCurrentArea === 'waitingAnchor') {\r\n          // TRANSLATE TO THE WRONG ANCHOR-----------------------------\r\n          translateDragElemFromAnswers({ dragId, anchorId: anchorId as number });\r\n\r\n          // TRANSLATE TO THE ORIGIN ANCHOR----------------------------\r\n          setDraggableId({ wordId: dragId, originId: originId });\r\n          setDragEndEvent('answers-wrong-waiting');\r\n        } else {\r\n          setBlockAnimation(true); // disable handlers\r\n\r\n          translateDragElemFromAnswers(\r\n            { dragId, anchorId: getAnswerPreparedAnchor().anchorId },\r\n            answersRef.current as HTMLDivElement\r\n          );\r\n          setDraggableId({ originId, wordId: dragId });\r\n          setDragEndEvent('answers-answers');\r\n        }\r\n      }\r\n    },\r\n    [\r\n      translateDragElemFromPending,\r\n      answersAnchors,\r\n      translateDragElemFromAnswers,\r\n      waitingWords,\r\n      answersWords,\r\n      waitingOriginCoords,\r\n      getAnswerPreparedAnchor,\r\n    ]\r\n  );\r\n\r\n  useEffect(() => {\r\n    switch (dragEndEvent) {\r\n      case 'waiting-answers': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          isTransitioned.current = true; // off transition\r\n\r\n          // show last anchor in answers area\r\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'setBusy'));\r\n\r\n          // shift words in waiting area\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            { wordsList: waitingWords, wordsArea: 'waiting' },\r\n            getConvertedWords(waitingWords)[draggableId.wordId],\r\n            'take'\r\n          );\r\n\r\n          setWaitingWords(\r\n            getShiftedWords(waitingWords, draggableId.wordId, idBeforeDraggableElem, {\r\n              elementAction: 'remove',\r\n              directionShift: 'left',\r\n            })\r\n          );\r\n\r\n          // add word to end of answers area\r\n          const targetWord = getConvertedWords(waitingWords)[draggableId.wordId];\r\n          setAnswersWords([\r\n            ...answersWords,\r\n            { ...targetWord, wordId: getEmptyAnswerAnchor(answersAnchors).anchorId, from: 'answers' },\r\n          ]);\r\n          resetOriginCoords(100);\r\n        }, TRANSITION_TIME);\r\n        break;\r\n      }\r\n      case 'answers-waiting': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          isTransitioned.current = true; // off transition\r\n\r\n          // shift waiting words\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            { wordsList: waitingWords, wordsArea: 'waiting' },\r\n            getConvertedWords(answersWords)[draggableId.wordId],\r\n            'put'\r\n          );\r\n          const shiftedwaitingWords = getShiftedWords(waitingWords, draggableId.originId, idBeforeDraggableElem, {\r\n            elementAction: 'add',\r\n            directionShift: 'right',\r\n          });\r\n          const convertedWords = getConvertedWords(shiftedwaitingWords);\r\n          convertedWords[draggableId.originId] = {\r\n            ...getConvertedWords(answersWords)[draggableId.wordId],\r\n            from: 'waiting',\r\n            wordId: draggableId.originId,\r\n          };\r\n          setWaitingWords(Object.values(convertedWords));\r\n\r\n          // shift answers words\r\n          const idBeforeAnswers = getIdBeforeDraggableElem(\r\n            { wordsList: answersWords, wordsArea: 'answers' },\r\n            getConvertedWords(answersWords)[draggableId.wordId],\r\n            'take'\r\n          );\r\n          const shiftedAnswersWords = getShiftedWords(answersWords, draggableId.wordId, idBeforeAnswers, {\r\n            elementAction: 'remove',\r\n            directionShift: 'left',\r\n          });\r\n          setAnswersWords(shiftedAnswersWords);\r\n\r\n          // hide last anchor in answers area\r\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'delBusy'));\r\n\r\n          resetOriginCoords(100);\r\n        }, TRANSITION_TIME);\r\n        break;\r\n      }\r\n      case 'answers-wrong-waiting': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          translateWaitingWords(draggableId.wordId);\r\n          translateDragElemFromAnswers({ dragId: draggableId.wordId, anchorId: draggableId.originId });\r\n\r\n          // UPDATE STATE---------------------------------------------\r\n          setDragEndEvent('answers-waiting');\r\n        }, TRANSITION_TIME + 500);\r\n        break;\r\n      }\r\n      case 'answers-answers': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          isTransitioned.current = true; // off transition\r\n\r\n          const targetWord = getConvertedWords(answersWords)[draggableId.wordId];\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            {\r\n              wordsList: answersWords,\r\n              wordsArea: 'answers',\r\n            },\r\n            targetWord,\r\n            'take'\r\n          );\r\n          const shiftedAnswerWords = getShiftedWords(answersWords, draggableId.wordId, idBeforeDraggableElem, {\r\n            elementAction: 'remove',\r\n            directionShift: 'left',\r\n          });\r\n          shiftedAnswerWords.push({ ...targetWord, wordId: shiftedAnswerWords.length });\r\n\r\n          setAnswersWords(shiftedAnswerWords);\r\n          setAnswersAnchors(\r\n            answersAnchors.map(anchor => (anchor.isPrepared ? { ...anchor, isPrepared: false } : anchor))\r\n          );\r\n          resetOriginCoords(100);\r\n        }, TRANSITION_TIME);\r\n        break;\r\n      }\r\n    }\r\n  }, [\r\n    answersAnchors,\r\n    answersWords,\r\n    dragEndEvent,\r\n    draggableId,\r\n    waitingWords,\r\n    translateDragElemFromAnswers,\r\n    translateWaitingWords,\r\n  ]);\r\n\r\n  return (\r\n    <StyledQuiz>\r\n      <Title content=\"Translate this sentence\" />\r\n      <QuizInfo>\r\n        <Avatar />\r\n        <Sentence>\r\n          {getQuestionText(quizId)\r\n            .split(' ')\r\n            .map((word, index) => (\r\n              <li key={index}>\r\n                <SentenceWord content={word} />\r\n              </li>\r\n            ))}\r\n        </Sentence>\r\n      </QuizInfo>\r\n      <QuizAnswersWrapper className=\"answers-wrapper\">\r\n        <DropArea\r\n          dragStartHandler={dragStartHandler}\r\n          dragMoveHandler={dragMoveHandler}\r\n          dragEndHandler={dragEndHandler}\r\n          originCoords={answersOriginCoords}\r\n          areaName=\"answersArea\"\r\n          words={answersWords}\r\n          anchors={answersAnchors}\r\n          isTransitioned={isTransitioned.current}\r\n          isBlockAnimaton={isBlockAnimaton}\r\n          ref={answersRef}\r\n        />\r\n      </QuizAnswersWrapper>\r\n      <QuizWaitingWrapper className=\"waiting-wrapper\">\r\n        <DropArea\r\n          dragStartHandler={dragStartHandler}\r\n          dragMoveHandler={dragMoveHandler}\r\n          dragEndHandler={dragEndHandler}\r\n          originCoords={waitingOriginCoords}\r\n          areaName=\"waitingArea\"\r\n          words={waitingWords}\r\n          anchors={getCorrectAnchors('ru', 'correct', quizId)}\r\n          isTransitioned={isTransitioned.current}\r\n          isBlockAnimaton={isBlockAnimaton}\r\n          ref={waitingRef}\r\n        />\r\n      </QuizWaitingWrapper>\r\n      <Message content={resultMessage} isError={isError} />\r\n      <QuizButtonWrapper className=\"btn-wrapper\">\r\n        <Button isMove={!!resultMessage} onclickHandler={isBlockAnimaton ? null : checkAnswerHandler} content=\"click\" />\r\n      </QuizButtonWrapper>\r\n    </StyledQuiz>\r\n  );\r\n};\r\n\r\nexport default Quiz;\r\n","import React from 'react';\r\nimport StyledApp from './App.styles';\r\nimport Quiz from './pages/Quiz/Quiz';\r\nconst App = () => {\r\n  return (\r\n    <StyledApp className=\"App\">\r\n      <Quiz quizId={'q1'} />\r\n    </StyledApp>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","export default __webpack_public_path__ + \"static/media/Roboto-Regular.96533686.woff\";","import { createGlobalStyle } from 'styled-components';\r\nimport { normalize } from 'styled-normalize';\r\nimport RobotoURLwoff from './Roboto/Roboto-Regular.woff';\r\nexport default createGlobalStyle`\r\n${normalize}\r\n@font-face {\r\n    font-family: 'Roboto';\r\n    src: url(${RobotoURLwoff}) format('woff');\r\n    font-weight: ${400};\r\n    font-style: normal;\r\n  }\r\n`;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport GlobalStyles from './settings/fonts/fonts';\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <GlobalStyles />\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\nreportWebVitals();\r\n"],"sourceRoot":""}
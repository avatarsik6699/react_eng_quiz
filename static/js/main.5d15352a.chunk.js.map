{"version":3,"sources":["atoms/Avatar/Avatar.tsx","atoms/Button/Button.tsx","atoms/SentenceWord/SentenceWord.tsx","atoms/Title/Title.tsx","molecules/Sentence/Sentence.tsx","settings/constants.ts","pages/Quiz/Quiz.helpers.ts","atoms/Message/Message.tsx","atoms/AnswerWord/AnswerWord.tsx","libs/Draggable/Draggable.tsx","atoms/Anchor/Anchor.tsx","molecules/DropArea/DropArea.tsx","pages/Quiz/Quiz.tsx","db.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Avatar","src","cls","className","alt","Button","content","onclickHandler","isTranslate","push","onClick","join","SentenceWord","Title","Sentence","children","TRANSITION_TIME","INITIAL_TRANSLATE_COORDS","x","y","INITIAL_SHIFT_COORDS","shiftX","shiftY","initialX","initialY","INITIAL_DRAGGABLE_ID","originId","wordId","getCorrectAnchors","words","targetAnchors","map","_","index","anchorId","isHidden","answerId","isPrepared","getConvertedAnchors","anchors","Array","isArray","reduce","acc","anchor","Object","values","getConvertedWords","word","getAnchorsDomList","anchorsDomRoot","from","length","matches","calcOriginCoords","root","idBeforeDraggableElem","settings","direction","coords","getAnchorsDomCoords","originCoords","id","getBoundingClientRect","getIdBeforeDraggableElem","draggableElem","action","wordsList","wordsArea","isGap","shiftedId","isBlocked","find","filter","getUpdatedAnswersAnchors","targetAnchor","convertedAnchors","reverse","getShiftedWords","dragId","elementAction","directionShift","includes","Message","isError","messageCls","textCls","AnswerWord","style","onMouseDown","React","memo","Draggable","draggableElemInfo","isTransitioned","dragStartHandler","dragMoveHandler","dragEndHandler","isBlockAnimaton","useState","isDragStart","setDragStart","setDraggableElem","inDropArea","useRef","currentArea","prevDropArea","debounce","translateCoords","setTranslateCoords","shiftCoords","setShiftCoords","setCurrentArea","useCallback","dropAreaName","current","isDraggableElemInDropArea","bellowElem","dataset","dropname","getBellowElement","target","classList","add","selector","elem","s","document","elementFromPoint","closest","defineElemFromPoint","remove","dragStart","ev","prevState","clientX","clientY","ondragstart","dragMove","currentAreaName","keys","getBellowElemDataAttr","dragEnd","bellowElement","console","log","Number","useEffect","window","addEventListener","removeEventListener","useMemo","willChange","transform","transition","Children","item","cloneElement","props","Anchor","isDataAttr","data-anchor","data-id","DropArea","forwardRef","ref","areaName","preparedWords","createWord","isDataAttribute","text","data-dropname","Math","ceil","row","slice","anchorWrapper","rowId","Quiz","sentenceText","resultMessage","setResultMessage","setError","setBlockAnimation","dragEndEvent","setDragEndEvent","waitingRef","answersRef","draggableId","setDraggableId","waitingOriginCoords","setWaitingOriginCoords","answersOriginCoords","setAnswersOriginCoords","getCorrectWords","waitingWords","setWaitingWords","answersWords","setAnswersWords","answersAnchors","setAnswersAnchors","getNewOriginCoords","prevOriginCoords","calculatedOriginCoords","getAnswerPreparedAnchor","getEmptyAnswerAnchor","resetOriginCoords","time","setTimeout","translateDragElemFromPending","params","targetAnchorCoords","draggableElemCoords","translateDragElemFromAnswers","anchorsRoot","translateWaitingWords","checkAnswerHandler","correctText","translation","toLowerCase","answersText","correctCurrentArea","isTargetWaitingAnchorBusy","targetWord","shiftedwaitingWords","convertedWords","idBeforeAnswers","shiftedAnswersWords","shiftedAnswerWords","q1","sentenceWords","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"idAYeA,EATA,SAAC,GAA2B,IAAzBC,EAAwB,EAAxBA,IACVC,EAAM,cACZ,OACE,qBAAKC,UAAU,SAAf,SACGF,EAAM,qBAAKE,UAAWD,EAAKD,IAAKA,EAAKG,IAAI,WAAc,qBAAKD,UAAS,UAAKD,EAAL,iBCO7DG,G,MAVA,SAAC,GAA4D,IAA1DC,EAAyD,EAAzDA,QAASC,EAAgD,EAAhDA,eACnBL,EAAM,CAAC,UAEb,OAHyE,EAAhCM,aAExBN,EAAIO,KAAK,gBAExB,wBAAQC,QAASH,EAAgBJ,UAAWD,EAAIS,KAAK,KAArD,SACGL,MCFQM,G,MAJM,SAAC,GAAqC,IAAnCN,EAAkC,EAAlCA,QACtB,OAAO,sBAAMH,UAAU,gBAAhB,SAAiCG,MCE3BO,G,MAJD,SAAC,GAA8B,IAA5BP,EAA2B,EAA3BA,QACf,OAAO,oBAAIH,UAAU,QAAd,SAAuBG,MCUjBQ,G,MATE,SAAC,GAAqC,IAAnCC,EAAkC,EAAlCA,SAClB,OACE,sBAAKZ,UAAU,WAAf,UACE,sBAAMA,UAAU,kBAChB,oBAAIA,UAAU,sBAAd,SAAqCY,SCRrCC,EAAkB,IAClBC,EAA2B,CAAEC,EAAG,EAAGC,EAAG,GACtCC,EAAuB,CAC3BC,OAAQ,EACRC,OAAQ,EACRC,SAAU,EACVC,SAAU,GAENC,EAAuB,CAC3BC,SAAU,EACVC,OAAQ,GCCJC,EAAoB,SAACC,EAAiBC,GAAlB,OACxBD,EAAME,KAAI,SAACC,EAAGC,GAAJ,MAAe,CACvBC,SAAUD,EACVE,SAA4B,YAAlBL,EACVM,SAAU,KACVC,YAAY,OAGVC,EAAsB,SAC1BC,GAD0B,OAG1BC,MAAMC,QAAQF,GACVA,EAAQG,QAAO,SAACC,EAAKC,GAAN,mBAAC,eAAsBD,GAAvB,kBAA6BC,EAAOV,SAApC,eAAoDU,OAAa,IAChFC,OAAOC,OAAOP,IAEdQ,EAAoB,SAAClB,GAAD,OACxBA,EAAMa,QAAO,SAACC,EAAKK,GAAN,mBAAC,eAAoBL,GAArB,kBAA2BK,EAAKrB,OAAhC,eAA8CqB,OAAW,KAElEC,EAAoB,SAApBA,EAA4CC,GAAxB,OACvBV,MAAMW,KAAKD,EAAenC,UAAkB2B,QAC3C,SAACH,EAAcK,GAAf,OAC6B,IAA3BA,EAAO7B,SAASqC,QAAiBR,EAAO7B,SAAS,GAAGsC,QAAQ,gBAA5D,sBAEQd,GAFR,CAEiBK,IAFjB,sBACQL,GADR,YACoBU,EAAkBL,OAExC,KAGEU,EAAmB,SACvBC,EACAC,EACAC,GACI,IACIC,GADL,OACmBD,QADnB,IACmBA,IAAY,CAAEC,UAAW,SAAvCA,UACFC,EAASC,EAAoBL,GACnC,OAAOC,EAAsBd,QAC3B,SAACmB,EAA6BC,GAA9B,mBAAC,eACID,GADL,kBAEGC,EAAK,CACJ5C,EAAGyC,EAAqB,UAAdD,EAAwBI,EAAK,EAAIA,EAAK,GAAG5C,EAAIyC,EAAOG,GAAI5C,EAClEC,EAAGwC,EAAqB,UAAdD,EAAwBI,EAAK,EAAIA,EAAK,GAAG3C,EAAIwC,EAAOG,GAAI3C,OAGtE,KAIEyC,EAAsB,SAACV,GAAD,OAC1BD,EAAkBC,GAAgBnB,KAAI,SAACa,GAAD,MAAa,CACjD1B,EAAG0B,EAAOmB,wBAAwB7C,EAClCC,EAAGyB,EAAOmB,wBAAwB5C,OAGhC6C,EAA2B,SAC/BnC,EACAoC,EACAC,GACI,IACIC,EAAyBtC,EAAzBsC,UAAWC,EAAcvC,EAAduC,UACbC,EAAQ,SAACrB,GACb,OAAIA,EAAKrB,OAAS2C,EAAY,GAC5BC,GAAY,GACL,IAEPD,GAAa,GACN,IAOPC,IADqB,YAAvBN,EAAcd,MAA4BgB,EAAUK,MAAK,SAACxB,GAAD,OAAUA,EAAKrB,SAAWsC,EAAcvC,aAE/F4C,EAAuB,QAAXJ,EAAmBD,EAAcvC,SAAWuC,EAActC,OAE1E,OAAOwC,EACJM,QAAO,SAACzB,GACP,MAAkB,YAAdoB,GACEG,IACW,QAAXL,EACElB,EAAKrB,QAAUsC,EAAcvC,UACxB2C,EAAMrB,GAKXA,EAAKrB,OAASsC,EAActC,QACvB0C,EAAMrB,IAMVA,EAAKrB,OAASsC,EAActC,UAGtCI,KAAI,SAACiB,GAAD,OAAUA,EAAKrB,WAGlB+C,EAA2B,SAC/BnC,EACA2B,GAEA,IACIS,EADEC,EAAmBtC,EAAoBC,GAE7C,OAAQ2B,GACN,IAAK,UACHS,EAAe,YAAIpC,GAASsC,UAAUL,MAAK,SAAC5B,GAAD,OAAYA,EAAOP,cAC9D,MAEF,IAAK,UACHsC,EAAe,YAAIpC,GAASsC,UAAUL,MAAK,SAAC5B,GAAD,OAAgC,OAApBA,EAAOR,YAC9D,MAEF,IAAK,aACHuC,EAAe,YAAIpC,GAASsC,UAAUL,MAAK,SAAC5B,GAAD,OAAYA,EAAOP,YAAkC,OAApBO,EAAOR,YACnF,MAEF,IAAK,cACHuC,EAAe,YAAIpC,GAASsC,UAAUL,MAAK,SAAC5B,GAAD,OAAgC,OAApBA,EAAOR,YAC9D,MAEF,QACEuC,EAAepC,EAAQiC,MAAK,SAAC5B,GAAD,OAAgC,OAApBA,EAAOR,YAcnD,OARIuC,IACFC,EAAiBD,EAAazC,UAA9B,2BACKyC,GADL,IAEEtC,WAAuB,YAAX6B,GAAmC,gBAAXA,EACpC9B,SAAqB,YAAX8B,GAAmC,gBAAXA,EAA2BS,EAAazC,SAAW,QAIlFI,EAAoBsC,IAGvBE,EAAkB,SACtBjD,EACAkD,EACAvB,EACAC,GACI,IACIuB,EAAkCvB,EAAlCuB,cAAeC,EAAmBxB,EAAnBwB,eAIvB,OADuC,QAAlBD,EAA0BnD,EAAQA,EAAM4C,QAAO,SAACzB,GAAD,OAAUA,EAAKrB,SAAWoD,MAC1EhD,KAAI,SAACiB,GAAD,OACtBQ,EAAsB0B,SAASlC,EAAKrB,QAApC,2BACSqB,GADT,IACerB,OAA2B,UAAnBsD,EAA6BjC,EAAKrB,OAAS,EAAIqB,EAAKrB,OAAS,IAChFqB,MCnJOmC,G,MAZC,SAAC,GAAyC,IAAvC7E,EAAsC,EAAtCA,QAAS8E,EAA6B,EAA7BA,QACpBC,EAAa,GACbC,EAAU,GAGhB,OAFIhF,GAAS+E,EAAW5E,KAAK,gBACzB2E,GAASE,EAAQ7E,KAAK,uBAExB,qBAAKN,UAAS,kBAAakF,EAAW1E,KAAK,MAA3C,SACE,sBAAMR,UAAS,wBAAmBmF,EAAQ3E,KAAK,MAA/C,SAAwDL,QCRxDiF,G,MAAa,SAAC,GAAuD,IAArDjF,EAAoD,EAApDA,QAASkF,EAA2C,EAA3CA,MAAOC,EAAoC,EAApCA,YAEpC,OACE,sBAAMD,MAAK,OAAEA,QAAF,IAAEA,IAAS,KAAMC,YAAW,OAAEA,QAAF,IAAEA,IAAe,KAAMtF,UAFpD,CAAC,eAEkEQ,KAAK,KAAlF,SACGL,MAKQoF,MAAMC,KAAKJ,GCPpBK,G,MAAY,SAAC,GASQ,IARzBC,EAQwB,EARxBA,kBACA9E,EAOwB,EAPxBA,SACA+E,EAMwB,EANxBA,eACAjC,EAKwB,EALxBA,aACAkC,EAIwB,EAJxBA,iBACAC,EAGwB,EAHxBA,gBACAC,EAEwB,EAFxBA,eACAC,EACwB,EADxBA,gBACwB,EAEYC,oBAAS,GAFrB,mBAEjBC,EAFiB,KAEJC,EAFI,OAGkBF,mBAA6B,MAH/C,mBAGjBlC,EAHiB,KAGFqC,EAHE,KAMlBC,EAAaC,kBAAO,GACpBC,EAAcD,iBAAkC,YAA3BX,EAAkB1C,KAAqB,cAAgB,eAC5EuD,EAAeF,iBAAkC,YAA3BX,EAAkB1C,KAAqB,cAAgB,eAC7EwD,EAAWH,mBATO,EAYsBL,mBAASlF,GAZ/B,mBAYjB2F,EAZiB,KAYAC,EAZA,OAacV,mBAAS/E,GAbvB,mBAajB0F,EAbiB,KAaJC,EAbI,KAyClBC,EAAiBC,uBAAY,SAACC,GAClC,OAAIX,EAAWY,SAAWD,GACpBR,EAAaS,UAAYD,IAG3BR,EAAaS,QAAUD,GAFhBA,GAMH,OAAN,OAAcR,EAAaS,WAE5B,IAEGC,EAA4BH,uBAChC,SAACI,GAAD,QAEEA,MACIA,EAAWC,QAAQC,WAAYF,EAAWhE,QAAQ,oCAIxD,IAGImE,EAAqCP,uBAAY,SAACQ,EAAQvG,EAAGC,GAGjEsG,EAAOC,UAAUC,IAAI,UACrB,IAAMN,EAzCoB,SAACO,EAA6BjE,GAA9B,aAC1BnB,MAAMC,QAAQmF,GACVA,EAASlF,QACP,SAACmF,EAA0BC,GAA3B,iBACW,OAATD,GAA0D,QAAzC,EAAAE,UAASC,iBAAT,oBAA6BrE,MACzC,EAAAoE,UAASC,iBAAT,oBAA6BrE,IAAwBsE,QAAQH,IAC3D,EAAAC,UAASC,iBAAT,oBAA6BrE,IAAwBsE,QAAQH,GAEhED,IACN,OAEA,EAAAE,UAASC,iBAAT,oBAA6BrE,IAAwBsE,QAAQL,GA8BhDM,CAHD,CAAC,gCAAiC,cAGF,CAAChH,EAAGC,IAGtD,OAFAsG,EAAOC,UAAUS,OAAO,UAExB,OAAOd,QAAP,IAAOA,IAAeU,SAASC,iBAAiB9G,EAAGC,KAClD,IAYGiH,EAAYnB,uBAChB,SAACoB,GACC,IAAMpE,EAAgBoE,EAAGZ,OACzBxD,EAAcyD,UAAUC,IAAI,aAC5BtB,GAAa,GACbC,EAAiBrC,GACjB8C,GAAe,SAACuB,GAAD,mBAAC,eACXA,GADU,IAEbjH,OAAQgH,EAAGE,QAAUtE,EAAcF,wBAAwB7C,EAC3DI,OAAQ+G,EAAGG,QAAUvE,EAAcF,wBAAwB5C,EAC3DI,SAAU0C,EAAcF,wBAAwB7C,EAChDM,SAAUyC,EAAcF,wBAAwB5C,OAGlD4E,EAAiB,CACf5C,KAAM0C,EAAkB1C,KACxB4B,OAAQc,EAAkBlE,SAE5BsC,EAAcwE,YAAc,kBAAM,KAEpC,CAAC1C,EAAkBF,IAGf6C,EAAWzB,uBACf,SAACoB,GAAoB,IACXE,EAA6BF,EAA7BE,QAASC,EAAoBH,EAApBG,QAASf,EAAWY,EAAXZ,OACpBJ,EAAaG,EAAiBC,EAAuBc,EAASC,GACpEjC,EAAWY,QAAUC,EAA0BC,GAC/C,IAAMsB,EAAkB3B,EAjGE,SAACK,GAC7B,OAAIA,GACgD,IAA3CxE,OAAO+F,KAAKvB,EAAWC,SAASlE,OACnCiE,EAAWC,QAAQC,SAChBF,EAAWC,QAAQC,SACnBF,EAAWC,QAAQ1E,OAGnB,KAyFgCiG,CAAsBxB,IAEzDsB,IAAoBhC,EAASQ,UAC/BR,EAASQ,QAAUwB,EACnBlC,EAAYU,QAAUwB,EACtB3C,EAAgB,CACd7C,KAAM0C,EAAkB1C,KACxBsD,YAAaA,EAAYU,WAI7BN,GAAmB,SAACyB,GAAD,mBAAC,eACfA,GADc,IAEjBpH,EAAGqH,EAAUzB,EAAYvF,SAAWuF,EAAYzF,OAChDF,EAAGqH,EAAU1B,EAAYtF,SAAWsF,EAAYxF,YAE9C+F,IAAYA,EAAWoB,YAAc,kBAAM,MAEjD,CACEzC,EACAH,EAAkB1C,KAClBqE,EACAJ,EACAJ,EACAF,EAAYvF,SACZuF,EAAYtF,SACZsF,EAAYzF,OACZyF,EAAYxF,SAIVwH,EAAU7B,uBACd,SAACoB,GAAoB,IACXE,EAA6BF,EAA7BE,QAASC,EAAoBH,EAApBG,QAASf,EAAWY,EAAXZ,OACb,OAAbxD,QAAa,IAAbA,KAAeyD,UAAUS,OAAO,aAChC,IAAMY,EAAgBvB,EAAiBC,EAAuBc,EAASC,GACvEQ,QAAQC,IAAIF,GACZ1C,GAAa,GACbQ,EAAmB5F,GAEnBgF,EAAe,CACb9C,KAAM0C,EAAkB1C,KACxBzB,SAAUmE,EAAkBnE,SAC5BqD,OAAQc,EAAkBlE,OAC1B8E,YAAaA,EAAYU,QACzBjF,SAAU6G,IACNA,EAAczB,QAAQxD,IAAmC,MAA7BiF,EAAczB,QAAQxD,IAChDoF,OAAOH,EAAczB,QAAQxD,IAE/B,SAGR,CACEmC,EADF,OAEEhC,QAFF,IAEEA,OAFF,EAEEA,EAAeyD,UACf7B,EAAkB1C,KAClB0C,EAAkBnE,SAClBmE,EAAkBlE,OAClB6F,IAIJ2B,qBAAU,WASR,OARI/C,IAAgBF,GAClBkD,OAAOC,iBAAiB,YAAaX,GACrCU,OAAOC,iBAAiB,UAAWP,KAEnCM,OAAOE,oBAAoB,YAAaZ,GACxCU,OAAOE,oBAAoB,UAAWR,IAGjC,WACLM,OAAOE,oBAAoB,YAAaZ,GACxCU,OAAOE,oBAAoB,UAAWR,MAEvC,CAACA,EAASJ,EAAUxC,EAAiBE,IAExC,IAAMZ,EAAQ+D,mBACZ,iBAAO,CACLC,WAAY,YACZC,UAAWrD,EAAW,4BAEpBQ,EAAgB1F,EAAI2C,EAAa3C,EAFb,uBAGpB0F,EAAgBzF,EAAI0C,EAAa1C,EAHb,2BAIL0C,EAAa3C,EAJR,eAIgB2C,EAAa1C,EAJ7B,OAKtBuI,WAAYtD,GAAeN,EAAiB,GAAhC,oBAAkD9E,EAAlD,cAEd,CAACoF,EAAaN,EAAgBjC,EAAa3C,EAAG2C,EAAa1C,EAAGyF,EAAgB1F,EAAG0F,EAAgBzF,IAGnG,OAAO,cAAC,WAAD,UA/HLuE,IAAMiE,SAAS5H,IAAIhB,GAAU,SAAC6I,GAAD,OAC3BlE,IAAMmE,aAAaD,EAAnB,2BACKA,EAAKE,OADV,IAEEtE,QACAC,YAAaS,EAAkB,KAAOkC,YA8H/B1C,MAAMC,KAAKC,GCzNpBmE,G,YAAS,SAAC,GAAsE,IAApEhJ,EAAmE,EAAnEA,SAAUoB,EAAyD,EAAzDA,SAAUE,EAA+C,EAA/CA,WAAY2H,EAAmC,EAAnCA,WAAYlG,EAAuB,EAAvBA,GACtD5D,EAAM,CAAC,UAGb,OAFKiC,GAAUjC,EAAIO,KAAK,eACpB4B,GAAYnC,EAAIO,KAAK,mBAEvB,oBAAIN,UAAWD,EAAIS,KAAK,KAAMsJ,cAAaD,EAAa,gBAAkB,KAAME,UAAS/H,EAAW,KAAO2B,EAA3G,gBACG/C,QADH,IACGA,IAAY,SAKJ2E,MAAMC,KAAKoE,GC6DXI,EAlEEC,sBACf,WAYEC,GACI,IAXFC,EAWC,EAXDA,SACA/H,EAUC,EAVDA,QACAV,EASC,EATDA,MACAgC,EAQC,EARDA,aACAkC,EAOC,EAPDA,iBACAC,EAMC,EANDA,gBACAC,EAKC,EALDA,eACAH,EAIC,EAJDA,eACAI,EAGC,EAHDA,gBAIIqE,EAA0C1I,EAAMa,QACpD,SAACC,EAAKiH,GAAN,mBAAC,eAAoBjH,GAArB,kBAA2BiH,EAAKjI,OAAhC,eAA8CiI,OAC9C,IAEIY,EAAa,SAAC5H,GAAD,MAAkB6H,EAAlB,+DACjB,cAAC,EAAD,CAEEtI,SAAUS,EAAOT,SACjBE,WAAYO,EAAOP,WACnB2H,WAAYS,EACZ3G,GAAIlB,EAAOV,SALb,SAOGqI,EAAc3H,EAAOV,WACpB,cAAC,EAAD,CACE2D,kBAAiB,eAAO0E,EAAc3H,EAAOV,WAC7C4D,eAAgBA,EAChBjC,aAAY,UAAEA,EAAajB,EAAOV,iBAAtB,QAAmC,CAAEhB,EAAG,EAAGC,EAAG,GAC1D4E,iBAAkBA,EAClBC,gBAAiBA,EACjBC,eAAgBA,EAChBC,gBAAiBA,EAPnB,SASE,cAAC,EAAD,CAAY5F,QAASiK,EAAc3H,EAAOV,UAAUwI,MAAWH,EAAc3H,EAAOV,UAAUP,WAhB7FiB,EAAOV,WAiChB,MAAoB,gBAAboI,EACL,qBAAKnK,UAAU,YAAYwK,gBAAeL,EAAUD,IAAKA,EAAzD,SAVA,YAAI7H,MAAMoI,KAAKC,KAAKtI,EAAQa,OAAS,IAAIwF,QAAQ7G,KAAI,SAAC+I,GAAD,OAASvI,EAAQwI,MAAY,EAAND,EAAqB,GAAXA,EAAM,OAGvE/I,KAAI,SAACiJ,EAAeC,GAAhB,OACvB,oBAAgB9K,UAAU,qBAA1B,SACG6K,EAAcjJ,KAAI,SAACa,GAAD,OAAY4H,EAAW5H,OADnCqI,QAUX,oBAAI9K,UAAU,YAAYwK,gBAAeL,EAAUD,IAAKA,EAAxD,SACG9H,EAAQR,KAAI,SAACa,GAAD,OAAY4H,EAAW5H,GAAQ,WC0WrCsI,EAhZF,SAAC,GAAyC,IAAvCC,EAAsC,EAAtCA,aAActJ,EAAwB,EAAxBA,MAAwB,EAEVsE,mBAAwB,MAFd,mBAE7CiF,EAF6C,KAE9BC,EAF8B,OAGxBlF,mBAAyB,MAHD,mBAG7Cf,EAH6C,KAGpCkG,EAHoC,OAMPnF,oBAAS,GANF,mBAM7CD,EAN6C,KAM5BqF,EAN4B,OAOZpF,mBAAiB,IAPL,mBAO7CqF,EAP6C,KAO/BC,EAP+B,KAQ9CC,EAAalF,iBAAO,MACpBmF,EAAanF,iBAAO,MACpBV,EAAiBU,kBAAO,GAVsB,EAWdL,mBAAuB1E,GAXT,mBAW7CmK,EAX6C,KAWhCC,EAXgC,OAcE1F,mBAAwB,IAd1B,mBAc7C2F,EAd6C,KAcxBC,EAdwB,OAeE5F,mBAAwB,IAf1B,oBAe7C6F,GAf6C,MAexBC,GAfwB,SAiBZ9F,mBN7ClB,SAACtE,GAAD,OACtBA,EAAME,KAAI,SAAC2I,EAAMzI,GAAP,MAAkB,CAC1ByI,OACA/I,OAAQM,EACRP,SAAUO,EACVkB,KAAM,cMwCkD+I,CAAgBrK,IAjBtB,qBAiB7CsK,GAjB6C,MAiB/BC,GAjB+B,SAkBZjG,mBAAkB,IAlBN,qBAkB7CkG,GAlB6C,MAkB/BC,GAlB+B,SAoBRnG,mBAASvE,EAAkBC,EAAO,YApB1B,qBAoB7C0K,GApB6C,MAoB7BC,GApB6B,MAuB9CC,GAAqBxF,uBACzB,SAACQ,EAA+B1C,GAC9B,IAAM2H,EAA8B,YAAXjF,EAAuBqE,EAAsBE,GAChEzI,EAAkB,YAAXkE,EAAwBiE,EAAWvE,QAA2BwE,EAAWxE,QAChF3D,EAAwBQ,EAC5B,CACEG,UAAsB,YAAXsD,EAAuB0E,GAAeE,GACjDjI,UAAWqD,GAEb1E,EAA6B,YAAX0E,EAAuB0E,GAAeE,IAActH,GACtE,QAEI4H,EAAyBrJ,EAAiBC,EAAMC,GACtD,OAAO,2BACFkJ,GACAC,KAGP,CAACX,GAAqBK,GAAcP,EAAqBK,KAGrDS,GAA0B3F,uBAC9B,kBAAM,YAAIsF,IAAgB1H,UAAUL,MAAK,SAAC5B,GAAD,OAAYA,EAAOP,gBAC5D,CAACkK,KAGGM,GAAuB,SAACtK,GAAD,OAAwBA,EAAQiC,MAAK,SAAC5B,GAAD,OAAgC,OAApBA,EAAOR,aAK/E0K,GAAoB,WAAuB,IAAtBC,EAAqB,uDAAN,EACxCd,GAAuB,IACvBF,EAAuB,IACvBiB,YAAW,kBAAMzB,GAAkB,KAAQwB,IAGvCE,GAA+BhG,uBACnC,SAACiG,GAAkD,IACzChL,EAAqBgL,EAArBhL,SAAU6C,EAAWmI,EAAXnI,OACZoI,EAAqBvJ,EAAoB+H,EAAWxE,SAAwBjF,GAC5EkL,EAAsBxJ,EAAoB8H,EAAWvE,SAAwBpC,GACnFgH,EAAuB,2BAClBD,GADiB,kBAEnB/G,EAAS,CACR7D,EAAGiM,EAAmBjM,EAAIkM,EAAoBlM,EAC9CC,EAAGgM,EAAmBhM,EAAIiM,EAAoBjM,QAIpD,CAAC2K,IAGGuB,GAA+BpG,uBACnC,SACEiG,GAEI,IADJI,EACG,uDAD8C5B,EAAWvE,QAEpDpC,EAAqBmI,EAArBnI,OAAQ7C,EAAagL,EAAbhL,SACVkL,EAAsBxJ,EAAoB+H,EAAWxE,SAAwBpC,GAC7EoI,EAAqBvJ,EAAoB0J,GAAapL,GAC5D+J,GAAuB,2BAClBD,IADiB,kBAEnBjH,EAAS,CACR7D,EAAGiM,EAAmBjM,EAAIkM,EAAoBlM,EAC9CC,EAAGgM,EAAmBhM,EAAIiM,EAAoBjM,QAIpD,CAAC6K,KAGGuB,GAAwBtG,uBAC5B,SAAClC,GACC,IAAMvB,EAAwBQ,EAC5B,CAAEG,UAAWgI,GAAc/H,UAAW,WACtCrB,EAAkBsJ,IAActH,GAChC,OAGFgH,EAAuB,2BAClBD,GACAxI,EAAiBoI,EAAWvE,QAAwB3D,EAAuB,CAAEE,UAAW,cAG/F,CAAC2I,GAAcP,EAAqBK,KAIhCqB,GAAqBvG,uBAAY,WACrC,IAAMwG,EAActC,EACjB1G,QAAO,SAACmF,GAAD,MAA+B,KAArBA,EAAK8D,eACtB3L,KAAI,SAAC6H,GAAD,OAAUA,EAAK8D,YAAYC,iBAC/BhN,KAAK,KACFiN,EAAcvB,GAAatK,KAAI,SAACiB,GAAD,OAAUA,EAAK0H,QAAM/J,KAAK,KAC/DqI,QAAQC,IAAIwE,EAAaG,GACrBH,IAAgBG,EAClBvC,EAAiB,mBAEjBC,GAAS,GACTD,EAAiB,sBAElB,CAACgB,GAAclB,IAEZpF,GAAsCkB,uBAC1C,YAAuB,IAApBlC,EAAmB,EAAnBA,OAAQ5B,EAAW,EAAXA,KACT2C,EAAeqB,SAAU,EACzBkE,EAAiB,MACjBC,EAAS,MACI,YAATnI,EACF4I,EAAuBU,GAAmB,UAAW1H,KAErDyH,GAAkB9H,EAAyB6H,GAAgB,gBAC3DN,GAAuBQ,GAAmB,UAAW1H,OAGzD,CAACwH,GAAgBE,KAGbzG,GAAoCiB,uBACxC,YAA4B,IAAzB9D,EAAwB,EAAxBA,KAAMsD,EAAkB,EAAlBA,YACM,YAATtD,IACkB,gBAAhBsD,GAA+B+F,GAAkB9H,EAAyB6H,GAAgB,YAC1E,oBAAhB9F,GACF+F,GAAkB9H,EAAyB6H,GAAgB,kBAIjE,CAACA,KAGGtG,GAAkCgB,uBACtC,YAAwD,IAArDlC,EAAoD,EAApDA,OAAQ5B,EAA4C,EAA5CA,KAAMsD,EAAsC,EAAtCA,YAAa/E,EAAyB,EAAzBA,SAAUQ,EAAe,EAAfA,SAatC,GAZAqJ,GAAkB,GACL,YAATpI,IACkB,gBAAhBsD,GAEFwG,GAA6B,CAAE/K,SAAU2K,GAAqBN,IAAgBrK,SAAU6C,WACxF8G,EAAe,CAAEnK,WAAUC,OAAQoD,IACnC0G,EAAgB,oBAEhBqB,GAAkB,MAIT,YAAT3J,EAAoB,CACtB,IAAM0K,EAtHsB,SAACpH,EAAqBvE,GAAtB,MAChB,kBAAhBuE,GAAmCxD,EAAkByI,EAAWvE,SAA6BjF,GAAUnB,SAAS,GAqHjF+M,CAA0BrH,EAAavE,GAC9D,cACAuE,EAEJ,GADAuC,QAAQC,IAAI4E,EAAoBpH,GACL,gBAAvBoH,EAAsC,CAExCR,GAA6B,CAAEtI,SAAQ7C,SAAUR,IAGjD,IAAM8B,EAAwBQ,EAC5B,CAAEG,UAAWgI,GAAc/H,UAAW,WACtCrB,EAAkBsJ,IAActH,GAChC,OAEFgH,EAAuB,2BAClBD,GACAxI,EAAiBoI,EAAWvE,QAAwB3D,EAAuB,CAAEE,UAAW,YAI7FmI,EAAe,CAAEnK,WAAUC,OAAQoD,IACnC0G,EAAgB,uBACgB,kBAAvBoC,GAETR,GAA6B,CAAEtI,SAAQ7C,SAAUA,IAGjD2J,EAAe,CAAElK,OAAQoD,EAAQrD,SAAUA,IAC3C+J,EAAgB,2BAEhBF,GAAkB,GAElB8B,GACE,CAAEtI,SAAQ7C,SAAU0K,KAA0B1K,UAC9CyJ,EAAWxE,SAEb0E,EAAe,CAAEnK,WAAUC,OAAQoD,IACnC0G,EAAgB,uBAItB,CACEwB,GACAV,GACAc,GACAlB,GACAE,GACAP,EACAc,KAkIJ,OA9HAzD,qBAAU,WACR,OAAQqC,GACN,IAAK,kBACHwB,YAAW,WACTvB,EAAgB,IAChB3F,EAAeqB,SAAU,EAGzBqF,GAAkB9H,EAAyB6H,GAAgB,YAG3D,IAAM/I,EAAwBQ,EAC5B,CAAEG,UAAWgI,GAAc/H,UAAW,WACtCrB,EAAkBoJ,IAAcP,EAAYjK,QAC5C,QAGFyK,GACEtH,EAAgBqH,GAAcP,EAAYjK,OAAQ6B,EAAuB,CACvEwB,cAAe,SACfC,eAAgB,UAKpB,IAAM8I,EAAahL,EAAkBoJ,IAAcP,EAAYjK,QAC/D2K,GAAgB,GAAD,mBACVD,IADU,aAAC,eAET0B,GAFQ,IAEIpM,OAAQkL,GAAqBN,IAAgBrK,SAAUiB,KAAM,eAEhF2J,GAAkB,OACjB9L,GACH,MAEF,IAAK,kBACHgM,YAAW,WACTvB,EAAgB,IAChB3F,EAAeqB,SAAU,EAGzB,IAAM3D,EAAwBQ,EAC5B,CAAEG,UAAWgI,GAAc/H,UAAW,WACtCrB,EAAkBsJ,IAAcT,EAAYjK,QAC5C,OAEIqM,EAAsBlJ,EAAgBqH,GAAcP,EAAYlK,SAAU8B,EAAuB,CACrGwB,cAAe,MACfC,eAAgB,UAEZgJ,EAAiBlL,EAAkBiL,GACzCC,EAAerC,EAAYlK,UAA3B,2BACKqB,EAAkBsJ,IAAcT,EAAYjK,SADjD,IAEEwB,KAAM,UACNxB,OAAQiK,EAAYlK,WAEtB0K,GAAgBvJ,OAAOC,OAAOmL,IAG9B,IAAMC,EAAkBlK,EACtB,CAAEG,UAAWkI,GAAcjI,UAAW,WACtCrB,EAAkBsJ,IAAcT,EAAYjK,QAC5C,QAEIwM,EAAsBrJ,EAAgBuH,GAAcT,EAAYjK,OAAQuM,EAAiB,CAC7FlJ,cAAe,SACfC,eAAgB,SAElBqH,GAAgB6B,GAGhB3B,GAAkB9H,EAAyB6H,GAAgB,YAE3DO,GAAkB,OACjB9L,GACH,MAEF,IAAK,wBACHgM,YAAW,WACTvB,EAAgB,IAChB8B,GAAsB3B,EAAYjK,QAClC0L,GAA6B,CAAEtI,OAAQ6G,EAAYjK,OAAQO,SAAU0J,EAAYlK,WAGjF+J,EAAgB,qBACfzK,KACH,MAEF,IAAK,kBACHgM,YAAW,WACTvB,EAAgB,IAChB3F,EAAeqB,SAAU,EAEzB,IAAM4G,EAAahL,EAAkBsJ,IAAcT,EAAYjK,QACzD6B,EAAwBQ,EAC5B,CACEG,UAAWkI,GACXjI,UAAW,WAEb2J,EACA,QAEIK,EAAqBtJ,EAAgBuH,GAAcT,EAAYjK,OAAQ6B,EAAuB,CAClGwB,cAAe,SACfC,eAAgB,SAElBmJ,EAAmB3N,KAAnB,2BAA6BsN,GAA7B,IAAyCpM,OAAQyM,EAAmBhL,UAEpEkJ,GAAgB8B,GAChB5B,GACED,GAAexK,KAAI,SAACa,GAAD,OAAaA,EAAOP,WAAP,2BAAyBO,GAAzB,IAAiCP,YAAY,IAAUO,MAEzFkK,GAAkB,OACjB9L,MAIN,CACDuL,GACAF,GACAb,EACAI,EACAO,GACAkB,GACAE,KAIA,sBAAKpN,UAAU,OAAf,UACE,cAAC,EAAD,CAAOG,QAAQ,4BACf,sBAAKH,UAAU,YAAf,UACE,cAAC,EAAD,IACA,cAAC,EAAD,UACGgL,EAAapJ,KAAI,SAACiB,EAAMf,GAAP,OAChB,6BACE,cAAC,EAAD,CAAc3B,QAAS0C,EAAK0H,QADrBzI,WAMf,qBAAK9B,UAAU,kBAAf,SACE,cAAC,EAAD,CACE4F,iBAAkBA,GAClBC,gBAAiBA,GACjBC,eAAgBA,GAChBpC,aAAcmI,GACd1B,SAAS,cACTzI,MAAOwK,GACP9J,QAASgK,GACTzG,eAAgBA,EAAeqB,QAC/BjB,gBAAiBA,EACjBmE,IAAKsB,MAGT,qBAAKxL,UAAU,kBAAf,SACE,cAAC,EAAD,CACE4F,iBAAkBA,GAClBC,gBAAiBA,GACjBC,eAAgBA,GAChBpC,aAAciI,EACdxB,SAAS,cACTzI,MAAOsK,GACP5J,QAASX,EAAkBC,EAAO,WAClCiE,eAAgBA,EAAeqB,QAC/BjB,gBAAiBA,EACjBmE,IAAKqB,MAGT,cAAC,EAAD,CAASpL,QAAS8K,EAAehG,QAASA,IAC1C,qBAAKjF,UAAU,cAAf,SACE,cAAC,EAAD,CACEK,YAAa4K,EACb7K,eAAgB2F,EAAkB,KAAOsH,GACzClN,QAAQ,gB,ECxaP,CACT+N,GAAI,CACFC,cAAe,CACb,CAAE5D,KAAM,KAAMgD,YAAa,gBAC3B,CAAEhD,KAAM,OAAQgD,YAAa,sBAC7B,CAAEhD,KAAM,OAAQgD,YAAa,4BAC7B,CAAEhD,KAAM,KAAMgD,YAAa,IAC3B,CAAEhD,KAAM,OAAQgD,YAAa,6BAE/BrB,aAAc,CAAC,qBAAO,eAAM,2BAAQ,8BCJGgC,GAAnCC,E,EAAAA,cAAejC,E,EAAAA,aASRkC,EARH,WACV,OACE,qBAAKpO,UAAU,MAAf,SACE,cAAC,EAAD,CAAMgL,aAAcmD,EAAezM,MAAOwK,OCKjCmC,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFpH,SAASqH,eAAe,SAE1BZ,M","file":"static/js/main.5d15352a.chunk.js","sourcesContent":["import React from 'react';\r\nimport { IAvatarProps } from './Avatar.types';\r\nimport './Avatar.scss';\r\nconst Avatar = ({ src }: IAvatarProps) => {\r\n  const cls = 'avatar__img';\r\n  return (\r\n    <div className=\"avatar\">\r\n      {src ? <img className={cls} src={src} alt=\"avatar\" /> : <div className={`${cls}-default`}></div>}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Avatar;\r\n","import React from 'react';\r\nimport './Button.scss';\r\nimport { IButtonProps } from './Button.types';\r\n\r\nconst Button = ({ content, onclickHandler, isTranslate }: IButtonProps) => {\r\n  const cls = ['button'];\r\n  if (isTranslate) cls.push('button_moved');\r\n  return (\r\n    <button onClick={onclickHandler} className={cls.join(' ')}>\r\n      {content}\r\n    </button>\r\n  );\r\n};\r\n\r\nexport default Button;\r\n","import React from 'react';\r\nimport { ISentenceWordProps } from './SentenceWord.types';\r\nimport './SentenceWord.scss';\r\nconst SentenceWord = ({ content }: ISentenceWordProps) => {\r\n  return <span className=\"sentence-word\">{content}</span>;\r\n};\r\n\r\nexport default SentenceWord;\r\n","import { ITitleProps } from './Title.types';\r\nimport './Title.scss';\r\nconst Title = ({ content }: ITitleProps) => {\r\n  return <h1 className=\"title\">{content}</h1>;\r\n};\r\n\r\nexport default Title;\r\n","import React from 'react';\r\nimport './Sentence.scss';\r\nimport { SentencePropsType } from './Sentence.types';\r\n\r\nconst Sentence = ({ children }: SentencePropsType) => {\r\n  return (\r\n    <div className=\"sentence\">\r\n      <span className=\"sentence__tip\"></span>\r\n      <ul className=\"sentence__word-list\">{children}</ul>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Sentence;\r\n","const TRANSITION_TIME = 500;\r\nconst INITIAL_TRANSLATE_COORDS = { x: 0, y: 0 };\r\nconst INITIAL_SHIFT_COORDS = {\r\n  shiftX: 0,\r\n  shiftY: 0,\r\n  initialX: 0,\r\n  initialY: 0,\r\n};\r\nconst INITIAL_DRAGGABLE_ID = {\r\n  originId: 0,\r\n  wordId: 0,\r\n};\r\nexport { TRANSITION_TIME, INITIAL_SHIFT_COORDS, INITIAL_TRANSLATE_COORDS, INITIAL_DRAGGABLE_ID };\r\n","import { IAnchor } from '../../atoms/Anchor/Anchor.types';\r\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\r\nimport { IOriginCoords } from './Quiz.types';\r\nconst getCorrectWords = (words: string[]): IWord[] =>\r\n  words.map((text, index) => ({\r\n    text,\r\n    wordId: index,\r\n    originId: index,\r\n    from: 'waiting',\r\n  }));\r\n\r\nconst getCorrectAnchors = (words: string[], targetAnchors: 'waiting' | 'answers'): IAnchor[] =>\r\n  words.map((_, index) => ({\r\n    anchorId: index,\r\n    isHidden: targetAnchors === 'answers',\r\n    answerId: null,\r\n    isPrepared: false,\r\n  }));\r\n\r\nconst getConvertedAnchors = <R extends IAnchor[] | { [key: string]: IAnchor }>(\r\n  anchors: R\r\n): R extends IAnchor[] ? { [key: string]: IAnchor } : IAnchor[] =>\r\n  Array.isArray(anchors)\r\n    ? anchors.reduce((acc, anchor) => ({ ...acc, [anchor.anchorId]: { ...anchor } }), {})\r\n    : Object.values(anchors);\r\n\r\nconst getConvertedWords = (words: IWord[]): { [key: string]: IWord } =>\r\n  words.reduce((acc, word) => ({ ...acc, [word.wordId]: { ...word } }), {});\r\n\r\nconst getAnchorsDomList = <T extends HTMLElement>(anchorsDomRoot: T): T[] =>\r\n  (Array.from(anchorsDomRoot.children) as T[]).reduce(\r\n    (anchors: T[], anchor) =>\r\n      anchor.children.length !== 0 && !anchor.children[0].matches('.answer-word')\r\n        ? [...anchors, ...getAnchorsDomList(anchor)]\r\n        : [...anchors, anchor],\r\n    []\r\n  );\r\n\r\nconst calcOriginCoords = (\r\n  root: HTMLElement,\r\n  idBeforeDraggableElem: number[],\r\n  settings?: { direction: 'right' | 'left' }\r\n) => {\r\n  const { direction } = settings ?? { direction: 'left' }; //default settings\r\n  const coords = getAnchorsDomCoords(root);\r\n  return idBeforeDraggableElem.reduce(\r\n    (originCoords: IOriginCoords, id) => ({\r\n      ...originCoords,\r\n      [id]: {\r\n        x: coords[direction === 'right' ? id + 1 : id - 1].x - coords[id].x,\r\n        y: coords[direction === 'right' ? id + 1 : id - 1].y - coords[id].y,\r\n      },\r\n    }),\r\n    {}\r\n  );\r\n};\r\n\r\nconst getAnchorsDomCoords = (anchorsDomRoot: HTMLElement) =>\r\n  getAnchorsDomList(anchorsDomRoot).map((anchor) => ({\r\n    x: anchor.getBoundingClientRect().x,\r\n    y: anchor.getBoundingClientRect().y,\r\n  }));\r\n\r\nconst getIdBeforeDraggableElem = (\r\n  words: { wordsList: IWord[]; wordsArea: 'waiting' | 'answers' }, // слова которые надо перестроить\r\n  draggableElem: IWord, // переносимое слово\r\n  action: 'put' | 'take' // кладем или берем слово\r\n) => {\r\n  const { wordsList, wordsArea } = words;\r\n  const isGap = (word: IWord) => {\r\n    if (word.wordId - shiftedId > 1) {\r\n      isBlocked = true;\r\n      return false;\r\n    } else {\r\n      shiftedId += 1;\r\n      return true;\r\n    }\r\n  };\r\n\r\n  // определяем есть ли кто то на месте только когда двигаемся из answerArea\r\n  const isAnchorBusy =\r\n    draggableElem.from === 'waiting' ? true : wordsList.find((word) => word.wordId === draggableElem.originId);\r\n  let isBlocked = isAnchorBusy ? false : true;\r\n  let shiftedId = action === 'put' ? draggableElem.originId : draggableElem.wordId;\r\n\r\n  return wordsList\r\n    .filter((word) => {\r\n      if (wordsArea === 'waiting') {\r\n        if (isBlocked) return false; // если есть разрыв / на месте originId пусто\r\n        if (action === 'put') {\r\n          if (word.wordId >= draggableElem.originId) {\r\n            return isGap(word);\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          if (word.wordId > draggableElem.wordId) {\r\n            return isGap(word);\r\n          } else {\r\n            return false;\r\n          }\r\n        }\r\n      } else {\r\n        return word.wordId > draggableElem.wordId;\r\n      }\r\n    })\r\n    .map((word) => word.wordId);\r\n};\r\n\r\nconst getUpdatedAnswersAnchors = (\r\n  anchors: IAnchor[],\r\n  action: 'setBusy' | 'delBusy' | 'prepare' | 'disprepare' | 'prepareLast'\r\n) => {\r\n  const convertedAnchors = getConvertedAnchors(anchors);\r\n  let targetAnchor;\r\n  switch (action) {\r\n    case 'setBusy': {\r\n      targetAnchor = [...anchors].reverse().find((anchor) => anchor.isPrepared);\r\n      break;\r\n    }\r\n    case 'delBusy': {\r\n      targetAnchor = [...anchors].reverse().find((anchor) => anchor.answerId !== null);\r\n      break;\r\n    }\r\n    case 'disprepare': {\r\n      targetAnchor = [...anchors].reverse().find((anchor) => anchor.isPrepared && anchor.answerId === null);\r\n      break;\r\n    }\r\n    case 'prepareLast': {\r\n      targetAnchor = [...anchors].reverse().find((anchor) => anchor.answerId !== null) as IAnchor;\r\n      break;\r\n    }\r\n    default: {\r\n      targetAnchor = anchors.find((anchor) => anchor.answerId === null);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // check on undefined\r\n  if (targetAnchor) {\r\n    convertedAnchors[targetAnchor.anchorId] = {\r\n      ...targetAnchor,\r\n      isPrepared: action === 'prepare' || action === 'prepareLast',\r\n      answerId: action === 'setBusy' || action === 'prepareLast' ? targetAnchor.anchorId : null,\r\n    };\r\n  }\r\n\r\n  return getConvertedAnchors(convertedAnchors);\r\n};\r\n\r\nconst getShiftedWords = (\r\n  words: IWord[],\r\n  dragId: number,\r\n  idBeforeDraggableElem: number[],\r\n  settings: { elementAction: 'remove' | 'add'; directionShift: 'left' | 'right' }\r\n) => {\r\n  const { elementAction, directionShift } = settings;\r\n\r\n  // если слово убирается из words, то удаляем его из words и сдвигаем только слова, расположенные правее\r\n  const correctWords = elementAction === 'add' ? words : words.filter((word) => word.wordId !== dragId);\r\n  return correctWords.map((word) =>\r\n    idBeforeDraggableElem.includes(word.wordId)\r\n      ? { ...word, wordId: directionShift === 'right' ? word.wordId + 1 : word.wordId - 1 }\r\n      : word\r\n  );\r\n};\r\n\r\nexport {\r\n  calcOriginCoords,\r\n  getAnchorsDomCoords,\r\n  getIdBeforeDraggableElem,\r\n  getShiftedWords,\r\n  getUpdatedAnswersAnchors,\r\n  getConvertedWords,\r\n  getAnchorsDomList,\r\n  getConvertedAnchors,\r\n  getCorrectWords,\r\n  getCorrectAnchors,\r\n};\r\n","import React from 'react';\r\nimport './Message.scss';\r\nimport { IMessageProps } from './Message.types';\r\n\r\nconst Message = ({ content, isError }: IMessageProps) => {\r\n  const messageCls = [];\r\n  const textCls = [];\r\n  if (content) messageCls.push('message_show');\r\n  if (isError) textCls.push('message__text_wrong');\r\n  return (\r\n    <div className={`message ${messageCls.join(' ')}`}>\r\n      <span className={`message__text ${textCls.join(' ')}`}>{content}</span>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Message;\r\n","import React from 'react';\r\nimport './AnswerWord.scss';\r\nimport { IAnswerWordProps } from './AnswerWord.types';\r\nconst AnswerWord = ({ content, style, onMouseDown }: IAnswerWordProps) => {\r\n  const cls = ['answer-word'];\r\n  return (\r\n    <span style={style ?? null} onMouseDown={onMouseDown ?? null} className={cls.join(' ')}>\r\n      {content}\r\n    </span>\r\n  );\r\n};\r\n\r\nexport default React.memo(AnswerWord);\r\n","import React, { Fragment, useCallback, useEffect, useMemo, useRef, useState } from 'react';\r\nimport { INITIAL_SHIFT_COORDS, INITIAL_TRANSLATE_COORDS, TRANSITION_TIME } from '../../settings/constants';\r\nimport { DraggablePropsType, GetBellowElement } from './Draggable.types';\r\nimport './Draggable.scss';\r\n\r\nconst Draggable = ({\r\n  draggableElemInfo,\r\n  children,\r\n  isTransitioned,\r\n  originCoords,\r\n  dragStartHandler,\r\n  dragMoveHandler,\r\n  dragEndHandler,\r\n  isBlockAnimaton,\r\n}: DraggablePropsType) => {\r\n  // ANIMATION CONTROL------------------------------------------------------------\r\n  const [isDragStart, setDragStart] = useState(false);\r\n  const [draggableElem, setDraggableElem] = useState<HTMLElement | null>(null);\r\n\r\n  // SETTINGS FOR DETERMINING THE CURRENT ZONE (bellow element)-------------------\r\n  const inDropArea = useRef(false);\r\n  const currentArea = useRef(draggableElemInfo.from === 'waiting' ? 'waitingArea' : 'answersArea');\r\n  const prevDropArea = useRef(draggableElemInfo.from === 'waiting' ? 'waitingArea' : 'answersArea');\r\n  const debounce = useRef<string>();\r\n\r\n  // TRANSLATE COORDS-------------------------------------------------------------\r\n  const [translateCoords, setTranslateCoords] = useState(INITIAL_TRANSLATE_COORDS);\r\n  const [shiftCoords, setShiftCoords] = useState(INITIAL_SHIFT_COORDS);\r\n\r\n  // HELPERS FUNCTIONS---------------------------------------------------\r\n  const getBellowElemDataAttr = (bellowElem: HTMLElement | null) => {\r\n    if (bellowElem) {\r\n      return Object.keys(bellowElem.dataset).length !== 0\r\n        ? bellowElem.dataset.dropname\r\n          ? (bellowElem.dataset.dropname as string)\r\n          : (bellowElem.dataset.anchor as string)\r\n        : null;\r\n    } else {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const defineElemFromPoint = (selector: string | string[], coords: [x: number, y: number]) =>\r\n    Array.isArray(selector)\r\n      ? selector.reduce(\r\n          (elem: HTMLElement | null, s) =>\r\n            elem === null && document.elementFromPoint(...coords) !== null\r\n              ? (document.elementFromPoint(...coords) as HTMLElement).closest(s)\r\n                ? (document.elementFromPoint(...coords) as HTMLElement).closest(s)\r\n                : elem\r\n              : elem,\r\n          null\r\n        )\r\n      : ((document.elementFromPoint(...coords) as HTMLElement).closest(selector) as HTMLElement);\r\n\r\n  const setCurrentArea = useCallback((dropAreaName: string | null) => {\r\n    if (inDropArea.current && dropAreaName) {\r\n      if (prevDropArea.current === dropAreaName) {\r\n        return dropAreaName;\r\n      } else {\r\n        prevDropArea.current = dropAreaName;\r\n        return dropAreaName;\r\n      }\r\n    } else {\r\n      return `out-${prevDropArea.current}`;\r\n    }\r\n  }, []);\r\n\r\n  const isDraggableElemInDropArea = useCallback(\r\n    (bellowElem: null | HTMLElement) =>\r\n      // если курсор выходит за viewport, то bellowElem = null\r\n      bellowElem\r\n        ? bellowElem.dataset.dropname || bellowElem.matches('[data-anchor=\"waitingAnchor\"]')\r\n          ? true\r\n          : false\r\n        : false,\r\n    []\r\n  );\r\n\r\n  const getBellowElement: GetBellowElement = useCallback((target, x, y) => {\r\n    const matchList = ['[data-anchor=\"waitingAnchor\"]', '.drop-area'];\r\n\r\n    target.classList.add('hidden');\r\n    const bellowElem = defineElemFromPoint(matchList, [x, y]);\r\n    target.classList.remove('hidden');\r\n\r\n    return bellowElem ?? (document.elementFromPoint(x, y) as HTMLElement);\r\n  }, []);\r\n\r\n  const makeDraggableElement = () =>\r\n    React.Children.map(children, (item) =>\r\n      React.cloneElement(item, {\r\n        ...item.props,\r\n        style,\r\n        onMouseDown: isBlockAnimaton ? null : dragStart,\r\n      })\r\n    );\r\n\r\n  // HANDLER FUNCTIONS---------------------------------------------------\r\n  const dragStart = useCallback(\r\n    (ev: React.MouseEvent<HTMLSpanElement>) => {\r\n      const draggableElem = ev.target as HTMLSpanElement;\r\n      draggableElem.classList.add('draggable');\r\n      setDragStart(true);\r\n      setDraggableElem(draggableElem);\r\n      setShiftCoords((prevState) => ({\r\n        ...prevState,\r\n        shiftX: ev.clientX - draggableElem.getBoundingClientRect().x,\r\n        shiftY: ev.clientY - draggableElem.getBoundingClientRect().y,\r\n        initialX: draggableElem.getBoundingClientRect().x,\r\n        initialY: draggableElem.getBoundingClientRect().y,\r\n      }));\r\n\r\n      dragStartHandler({\r\n        from: draggableElemInfo.from,\r\n        dragId: draggableElemInfo.wordId,\r\n      });\r\n      draggableElem.ondragstart = () => false;\r\n    },\r\n    [dragStartHandler, draggableElemInfo]\r\n  );\r\n\r\n  const dragMove = useCallback(\r\n    (ev: MouseEvent) => {\r\n      const { clientX, clientY, target } = ev;\r\n      const bellowElem = getBellowElement(target as HTMLElement, clientX, clientY);\r\n      inDropArea.current = isDraggableElemInDropArea(bellowElem);\r\n      const currentAreaName = setCurrentArea(getBellowElemDataAttr(bellowElem));\r\n\r\n      if (currentAreaName !== debounce.current) {\r\n        debounce.current = currentAreaName;\r\n        currentArea.current = currentAreaName;\r\n        dragMoveHandler({\r\n          from: draggableElemInfo.from,\r\n          currentArea: currentArea.current as 'out-answersArea' | 'answersArea',\r\n        });\r\n      }\r\n\r\n      setTranslateCoords((prevState) => ({\r\n        ...prevState,\r\n        x: clientX - shiftCoords.initialX - shiftCoords.shiftX,\r\n        y: clientY - shiftCoords.initialY - shiftCoords.shiftY,\r\n      }));\r\n      if (bellowElem) bellowElem.ondragstart = () => false;\r\n    },\r\n    [\r\n      dragMoveHandler,\r\n      draggableElemInfo.from,\r\n      getBellowElement,\r\n      isDraggableElemInDropArea,\r\n      setCurrentArea,\r\n      shiftCoords.initialX,\r\n      shiftCoords.initialY,\r\n      shiftCoords.shiftX,\r\n      shiftCoords.shiftY,\r\n    ]\r\n  );\r\n\r\n  const dragEnd = useCallback(\r\n    (ev: MouseEvent) => {\r\n      const { clientX, clientY, target } = ev;\r\n      draggableElem?.classList.remove('draggable');\r\n      const bellowElement = getBellowElement(target as HTMLElement, clientX, clientY);\r\n      console.log(bellowElement);\r\n      setDragStart(false);\r\n      setTranslateCoords(INITIAL_TRANSLATE_COORDS);\r\n\r\n      dragEndHandler({\r\n        from: draggableElemInfo.from,\r\n        originId: draggableElemInfo.originId,\r\n        dragId: draggableElemInfo.wordId,\r\n        currentArea: currentArea.current as 'waitingArea' | 'answersArea' | 'waitingAnchor',\r\n        anchorId: bellowElement\r\n          ? bellowElement.dataset.id || bellowElement.dataset.id === '0'\r\n            ? Number(bellowElement.dataset.id)\r\n            : null\r\n          : null,\r\n      });\r\n    },\r\n    [\r\n      dragEndHandler,\r\n      draggableElem?.classList,\r\n      draggableElemInfo.from,\r\n      draggableElemInfo.originId,\r\n      draggableElemInfo.wordId,\r\n      getBellowElement,\r\n    ]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (isDragStart && !isBlockAnimaton) {\r\n      window.addEventListener('mousemove', dragMove);\r\n      window.addEventListener('mouseup', dragEnd);\r\n    } else {\r\n      window.removeEventListener('mousemove', dragMove);\r\n      window.removeEventListener('mouseup', dragEnd);\r\n    }\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', dragMove);\r\n      window.removeEventListener('mouseup', dragEnd);\r\n    };\r\n  }, [dragEnd, dragMove, isBlockAnimaton, isDragStart]);\r\n\r\n  const style = useMemo(\r\n    () => ({\r\n      willChange: 'transform',\r\n      transform: isDragStart\r\n        ? `translate(\r\n      ${translateCoords.x + originCoords.x}px, \r\n      ${translateCoords.y + originCoords.y}px)`\r\n        : `translate(${originCoords.x}px, ${originCoords.y}px)`,\r\n      transition: isDragStart || isTransitioned ? '' : `transform ${TRANSITION_TIME}ms ease`,\r\n    }),\r\n    [isDragStart, isTransitioned, originCoords.x, originCoords.y, translateCoords.x, translateCoords.y]\r\n  );\r\n\r\n  return <Fragment>{makeDraggableElement()}</Fragment>;\r\n};\r\n\r\nexport default React.memo(Draggable);\r\n","import React from 'react';\r\nimport './Anchor.scss';\r\nimport { IAnchorProps } from './Anchor.types';\r\nconst Anchor = ({ children, isHidden, isPrepared, isDataAttr, id }: IAnchorProps) => {\r\n  const cls = ['anchor'];\r\n  if (!isHidden) cls.push('anchor_show');\r\n  if (isPrepared) cls.push('anchor_prepared');\r\n  return (\r\n    <li className={cls.join(' ')} data-anchor={isDataAttr ? 'waitingAnchor' : null} data-id={isHidden ? null : id}>\r\n      {children ?? null}\r\n    </li>\r\n  );\r\n};\r\n\r\nexport default React.memo(Anchor);\r\n","import React, { forwardRef } from 'react';\r\nimport AnswerWord from '../../atoms/AnswerWord/AnswerWord';\r\nimport { IDropAreaProps } from './DropArea.types';\r\nimport Draggable from '../../libs/Draggable/Draggable';\r\nimport './DropArea.scss';\r\nimport Anchor from '../../atoms/Anchor/Anchor';\r\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\r\nimport { IAnchor } from '../../atoms/Anchor/Anchor.types';\r\n\r\nconst DropArea = forwardRef<any, IDropAreaProps>(\r\n  (\r\n    {\r\n      areaName,\r\n      anchors,\r\n      words,\r\n      originCoords,\r\n      dragStartHandler,\r\n      dragMoveHandler,\r\n      dragEndHandler,\r\n      isTransitioned,\r\n      isBlockAnimaton,\r\n    },\r\n    ref\r\n  ) => {\r\n    const preparedWords: { [key: string]: IWord } = words.reduce(\r\n      (acc, item) => ({ ...acc, [item.wordId]: { ...item } }),\r\n      {}\r\n    );\r\n    const createWord = (anchor: IAnchor, isDataAttribute: boolean = false) => (\r\n      <Anchor\r\n        key={anchor.anchorId}\r\n        isHidden={anchor.isHidden}\r\n        isPrepared={anchor.isPrepared}\r\n        isDataAttr={isDataAttribute}\r\n        id={anchor.anchorId}\r\n      >\r\n        {preparedWords[anchor.anchorId] && (\r\n          <Draggable\r\n            draggableElemInfo={{ ...preparedWords[anchor.anchorId] }}\r\n            isTransitioned={isTransitioned}\r\n            originCoords={originCoords[anchor.anchorId] ?? { x: 0, y: 0 }}\r\n            dragStartHandler={dragStartHandler}\r\n            dragMoveHandler={dragMoveHandler}\r\n            dragEndHandler={dragEndHandler}\r\n            isBlockAnimaton={isBlockAnimaton}\r\n          >\r\n            <AnswerWord content={preparedWords[anchor.anchorId].text} key={preparedWords[anchor.anchorId].wordId} />\r\n          </Draggable>\r\n        )}\r\n      </Anchor>\r\n    );\r\n\r\n    // [words] => [[words],[words],[wrods]...]\r\n    const getPreparedAnchors = () =>\r\n      [...Array(Math.ceil(anchors.length / 6)).keys()].map((row) => anchors.slice(row * 6, (row + 1) * 6));\r\n\r\n    const createAnchors = () =>\r\n      getPreparedAnchors().map((anchorWrapper, rowId) => (\r\n        <ul key={rowId} className=\"drop-area__wrapper\">\r\n          {anchorWrapper.map((anchor) => createWord(anchor))}\r\n        </ul>\r\n      ));\r\n\r\n    return areaName === 'answersArea' ? (\r\n      <div className=\"drop-area\" data-dropname={areaName} ref={ref}>\r\n        {createAnchors()}\r\n      </div>\r\n    ) : (\r\n      <ul className=\"drop-area\" data-dropname={areaName} ref={ref}>\r\n        {anchors.map((anchor) => createWord(anchor, true))}\r\n      </ul>\r\n    );\r\n  }\r\n);\r\n\r\nexport default DropArea;\r\n","import './Quiz.scss';\r\nimport React, { RefObject, useCallback, useEffect, useRef, useState } from 'react';\r\nimport Avatar from '../../atoms/Avatar/Avatar';\r\nimport Button from '../../atoms/Button/Button';\r\nimport SentenceWord from '../../atoms/SentenceWord/SentenceWord';\r\nimport Title from '../../atoms/Title/Title';\r\nimport Sentence from '../../molecules/Sentence/Sentence';\r\nimport { INITIAL_DRAGGABLE_ID, TRANSITION_TIME } from '../../settings/constants';\r\nimport { IAnchor } from '../../atoms/Anchor/Anchor.types';\r\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\r\nimport {\r\n  calcOriginCoords,\r\n  getAnchorsDomCoords,\r\n  getConvertedWords,\r\n  getCorrectAnchors,\r\n  getCorrectWords,\r\n  getIdBeforeDraggableElem,\r\n  getShiftedWords,\r\n  getUpdatedAnswersAnchors,\r\n  getAnchorsDomList,\r\n} from './Quiz.helpers';\r\nimport Message from '../../atoms/Message/Message';\r\nimport {\r\n  IOriginCoords,\r\n  IQuizProps,\r\n  TDragEndHandler,\r\n  TDraggableId,\r\n  TDragMoveHandler,\r\n  TDragStartHandler,\r\n} from './Quiz.types';\r\nimport DropArea from '../../molecules/DropArea/DropArea';\r\nconst Quiz = ({ sentenceText, words }: IQuizProps) => {\r\n  // result-info----------------------------------------------------------\r\n  const [resultMessage, setResultMessage] = useState<string | null>(null);\r\n  const [isError, setError] = useState<boolean | null>(null);\r\n\r\n  // animation-data------------------------------------------------------\r\n  const [isBlockAnimaton, setBlockAnimation] = useState(false);\r\n  const [dragEndEvent, setDragEndEvent] = useState<string>('');\r\n  const waitingRef = useRef(null) as RefObject<HTMLUListElement>;\r\n  const answersRef = useRef(null) as RefObject<HTMLDivElement>;\r\n  const isTransitioned = useRef(false);\r\n  const [draggableId, setDraggableId] = useState<TDraggableId>(INITIAL_DRAGGABLE_ID);\r\n\r\n  // origin-coords-------------------------------------------------------\r\n  const [waitingOriginCoords, setWaitingOriginCoords] = useState<IOriginCoords>({});\r\n  const [answersOriginCoords, setAnswersOriginCoords] = useState<IOriginCoords>({});\r\n  // words---------------------------------------------------------------\r\n  const [waitingWords, setWaitingWords] = useState<IWord[]>(getCorrectWords(words));\r\n  const [answersWords, setAnswersWords] = useState<IWord[]>([]);\r\n  // anchors-------------------------------------------------------------\r\n  const [answersAnchors, setAnswersAnchors] = useState(getCorrectAnchors(words, 'answers'));\r\n\r\n  // HELPER FUNCTIONS---------------------------------------------\r\n  const getNewOriginCoords = useCallback(\r\n    (target: 'waiting' | 'answers', dragId: number): IOriginCoords => {\r\n      const prevOriginCoords = target === 'waiting' ? waitingOriginCoords : answersOriginCoords;\r\n      const root = target === 'waiting' ? (waitingRef.current as HTMLElement) : (answersRef.current as HTMLElement);\r\n      const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n        {\r\n          wordsList: target === 'waiting' ? waitingWords : answersWords,\r\n          wordsArea: target,\r\n        },\r\n        getConvertedWords(target === 'waiting' ? waitingWords : answersWords)[dragId],\r\n        'take'\r\n      );\r\n      const calculatedOriginCoords = calcOriginCoords(root, idBeforeDraggableElem);\r\n      return {\r\n        ...prevOriginCoords,\r\n        ...calculatedOriginCoords,\r\n      };\r\n    },\r\n    [answersOriginCoords, answersWords, waitingOriginCoords, waitingWords]\r\n  );\r\n\r\n  const getAnswerPreparedAnchor = useCallback(\r\n    () => [...answersAnchors].reverse().find((anchor) => anchor.isPrepared) as IAnchor,\r\n    [answersAnchors]\r\n  );\r\n\r\n  const getEmptyAnswerAnchor = (anchors: IAnchor[]) => anchors.find((anchor) => anchor.answerId === null) as IAnchor;\r\n\r\n  const isTargetWaitingAnchorBusy = (currentArea: string, anchorId: number) =>\r\n    currentArea === 'waitingAnchor' && getAnchorsDomList(waitingRef.current as HTMLUListElement)[anchorId].children[0];\r\n\r\n  const resetOriginCoords = (time: number = 0) => {\r\n    setAnswersOriginCoords({});\r\n    setWaitingOriginCoords({});\r\n    setTimeout(() => setBlockAnimation(false), time);\r\n  };\r\n\r\n  const translateDragElemFromPending = useCallback(\r\n    (params: { anchorId: number; dragId: number }) => {\r\n      const { anchorId, dragId } = params;\r\n      const targetAnchorCoords = getAnchorsDomCoords(answersRef.current as HTMLElement)[anchorId];\r\n      const draggableElemCoords = getAnchorsDomCoords(waitingRef.current as HTMLElement)[dragId];\r\n      setWaitingOriginCoords({\r\n        ...waitingOriginCoords,\r\n        [dragId]: {\r\n          x: targetAnchorCoords.x - draggableElemCoords.x,\r\n          y: targetAnchorCoords.y - draggableElemCoords.y,\r\n        },\r\n      });\r\n    },\r\n    [waitingOriginCoords]\r\n  );\r\n\r\n  const translateDragElemFromAnswers = useCallback(\r\n    (\r\n      params: { dragId: number; anchorId: number },\r\n      anchorsRoot: HTMLDivElement | HTMLUListElement = waitingRef.current as HTMLUListElement\r\n    ) => {\r\n      const { dragId, anchorId } = params;\r\n      const draggableElemCoords = getAnchorsDomCoords(answersRef.current as HTMLElement)[dragId];\r\n      const targetAnchorCoords = getAnchorsDomCoords(anchorsRoot)[anchorId];\r\n      setAnswersOriginCoords({\r\n        ...answersOriginCoords,\r\n        [dragId]: {\r\n          x: targetAnchorCoords.x - draggableElemCoords.x,\r\n          y: targetAnchorCoords.y - draggableElemCoords.y,\r\n        },\r\n      });\r\n    },\r\n    [answersOriginCoords]\r\n  );\r\n\r\n  const translateWaitingWords = useCallback(\r\n    (dragId: number) => {\r\n      const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n        { wordsList: waitingWords, wordsArea: 'waiting' },\r\n        getConvertedWords(answersWords)[dragId],\r\n        'put'\r\n      );\r\n\r\n      setWaitingOriginCoords({\r\n        ...waitingOriginCoords,\r\n        ...calcOriginCoords(waitingRef.current as HTMLElement, idBeforeDraggableElem, { direction: 'right' }),\r\n      });\r\n    },\r\n    [answersWords, waitingOriginCoords, waitingWords]\r\n  );\r\n\r\n  // HANDLER FUNCTIONS---------------------------------------------\r\n  const checkAnswerHandler = useCallback(() => {\r\n    const correctText = sentenceText\r\n      .filter((item) => item.translation !== '')\r\n      .map((item) => item.translation.toLowerCase())\r\n      .join(' ');\r\n    const answersText = answersWords.map((word) => word.text).join(' ');\r\n    console.log(correctText, answersText);\r\n    if (correctText === answersText) {\r\n      setResultMessage('is complete!!!');\r\n    } else {\r\n      setError(true);\r\n      setResultMessage('something wrong');\r\n    }\r\n  }, [answersWords, sentenceText]);\r\n\r\n  const dragStartHandler: TDragStartHandler = useCallback(\r\n    ({ dragId, from }) => {\r\n      isTransitioned.current = false; // enable transition\r\n      setResultMessage(null);\r\n      setError(null);\r\n      if (from === 'waiting') {\r\n        setWaitingOriginCoords(getNewOriginCoords('waiting', dragId));\r\n      } else {\r\n        setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'prepareLast'));\r\n        setAnswersOriginCoords(getNewOriginCoords('answers', dragId));\r\n      }\r\n    },\r\n    [answersAnchors, getNewOriginCoords]\r\n  );\r\n\r\n  const dragMoveHandler: TDragMoveHandler = useCallback(\r\n    ({ from, currentArea }) => {\r\n      if (from === 'waiting') {\r\n        if (currentArea === 'answersArea') setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'prepare'));\r\n        if (currentArea === 'out-answersArea') {\r\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'disprepare'));\r\n        }\r\n      }\r\n    },\r\n    [answersAnchors]\r\n  );\r\n\r\n  const dragEndHandler: TDragEndHandler = useCallback(\r\n    ({ dragId, from, currentArea, originId, anchorId }) => {\r\n      setBlockAnimation(true); // disable handlers\r\n      if (from === 'waiting') {\r\n        if (currentArea === 'answersArea') {\r\n          // ANIMATION-----------------------------------------\r\n          translateDragElemFromPending({ anchorId: getEmptyAnswerAnchor(answersAnchors).anchorId, dragId });\r\n          setDraggableId({ originId, wordId: dragId });\r\n          setDragEndEvent('waiting-answers');\r\n        } else {\r\n          resetOriginCoords(100);\r\n        }\r\n      }\r\n\r\n      if (from === 'answers') {\r\n        const correctCurrentArea = isTargetWaitingAnchorBusy(currentArea, anchorId as number)\r\n          ? 'waitingArea'\r\n          : currentArea;\r\n        console.log(correctCurrentArea, currentArea);\r\n        if (correctCurrentArea === 'waitingArea') {\r\n          // translate drag elem to pending\r\n          translateDragElemFromAnswers({ dragId, anchorId: originId });\r\n\r\n          // translate pending words\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            { wordsList: waitingWords, wordsArea: 'waiting' },\r\n            getConvertedWords(answersWords)[dragId],\r\n            'put'\r\n          );\r\n          setWaitingOriginCoords({\r\n            ...waitingOriginCoords,\r\n            ...calcOriginCoords(waitingRef.current as HTMLElement, idBeforeDraggableElem, { direction: 'right' }),\r\n          });\r\n\r\n          //UPDATE STATE----------------------------------\r\n          setDraggableId({ originId, wordId: dragId });\r\n          setDragEndEvent('answers-waiting');\r\n        } else if (correctCurrentArea === 'waitingAnchor') {\r\n          // TRANSLATE TO THE WRONG ANCHOR-----------------------------\r\n          translateDragElemFromAnswers({ dragId, anchorId: anchorId as number });\r\n\r\n          // TRANSLATE TO THE ORIGIN ANCHOR----------------------------\r\n          setDraggableId({ wordId: dragId, originId: originId });\r\n          setDragEndEvent('answers-wrong-waiting');\r\n        } else {\r\n          setBlockAnimation(true); // disable handlers\r\n\r\n          translateDragElemFromAnswers(\r\n            { dragId, anchorId: getAnswerPreparedAnchor().anchorId },\r\n            answersRef.current as HTMLDivElement\r\n          );\r\n          setDraggableId({ originId, wordId: dragId });\r\n          setDragEndEvent('answers-answers');\r\n        }\r\n      }\r\n    },\r\n    [\r\n      translateDragElemFromPending,\r\n      answersAnchors,\r\n      translateDragElemFromAnswers,\r\n      waitingWords,\r\n      answersWords,\r\n      waitingOriginCoords,\r\n      getAnswerPreparedAnchor,\r\n    ]\r\n  );\r\n\r\n  useEffect(() => {\r\n    switch (dragEndEvent) {\r\n      case 'waiting-answers': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          isTransitioned.current = true; // off transition\r\n\r\n          // show last anchor in answers area\r\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'setBusy'));\r\n\r\n          // shift words in waiting area\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            { wordsList: waitingWords, wordsArea: 'waiting' },\r\n            getConvertedWords(waitingWords)[draggableId.wordId],\r\n            'take'\r\n          );\r\n\r\n          setWaitingWords(\r\n            getShiftedWords(waitingWords, draggableId.wordId, idBeforeDraggableElem, {\r\n              elementAction: 'remove',\r\n              directionShift: 'left',\r\n            })\r\n          );\r\n\r\n          // add word to end of answers area\r\n          const targetWord = getConvertedWords(waitingWords)[draggableId.wordId];\r\n          setAnswersWords([\r\n            ...answersWords,\r\n            { ...targetWord, wordId: getEmptyAnswerAnchor(answersAnchors).anchorId, from: 'answers' },\r\n          ]);\r\n          resetOriginCoords(100);\r\n        }, TRANSITION_TIME);\r\n        break;\r\n      }\r\n      case 'answers-waiting': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          isTransitioned.current = true; // off transition\r\n\r\n          // shift waiting words\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            { wordsList: waitingWords, wordsArea: 'waiting' },\r\n            getConvertedWords(answersWords)[draggableId.wordId],\r\n            'put'\r\n          );\r\n          const shiftedwaitingWords = getShiftedWords(waitingWords, draggableId.originId, idBeforeDraggableElem, {\r\n            elementAction: 'add',\r\n            directionShift: 'right',\r\n          });\r\n          const convertedWords = getConvertedWords(shiftedwaitingWords);\r\n          convertedWords[draggableId.originId] = {\r\n            ...getConvertedWords(answersWords)[draggableId.wordId],\r\n            from: 'waiting',\r\n            wordId: draggableId.originId,\r\n          };\r\n          setWaitingWords(Object.values(convertedWords));\r\n\r\n          // shift answers words\r\n          const idBeforeAnswers = getIdBeforeDraggableElem(\r\n            { wordsList: answersWords, wordsArea: 'answers' },\r\n            getConvertedWords(answersWords)[draggableId.wordId],\r\n            'take'\r\n          );\r\n          const shiftedAnswersWords = getShiftedWords(answersWords, draggableId.wordId, idBeforeAnswers, {\r\n            elementAction: 'remove',\r\n            directionShift: 'left',\r\n          });\r\n          setAnswersWords(shiftedAnswersWords);\r\n\r\n          // hide last anchor in answers area\r\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'delBusy'));\r\n\r\n          resetOriginCoords(100);\r\n        }, TRANSITION_TIME);\r\n        break;\r\n      }\r\n      case 'answers-wrong-waiting': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          translateWaitingWords(draggableId.wordId);\r\n          translateDragElemFromAnswers({ dragId: draggableId.wordId, anchorId: draggableId.originId });\r\n\r\n          // UPDATE STATE---------------------------------------------\r\n          setDragEndEvent('answers-waiting');\r\n        }, TRANSITION_TIME + 500);\r\n        break;\r\n      }\r\n      case 'answers-answers': {\r\n        setTimeout(() => {\r\n          setDragEndEvent('');\r\n          isTransitioned.current = true; // off transition\r\n\r\n          const targetWord = getConvertedWords(answersWords)[draggableId.wordId];\r\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\r\n            {\r\n              wordsList: answersWords,\r\n              wordsArea: 'answers',\r\n            },\r\n            targetWord,\r\n            'take'\r\n          );\r\n          const shiftedAnswerWords = getShiftedWords(answersWords, draggableId.wordId, idBeforeDraggableElem, {\r\n            elementAction: 'remove',\r\n            directionShift: 'left',\r\n          });\r\n          shiftedAnswerWords.push({ ...targetWord, wordId: shiftedAnswerWords.length });\r\n\r\n          setAnswersWords(shiftedAnswerWords);\r\n          setAnswersAnchors(\r\n            answersAnchors.map((anchor) => (anchor.isPrepared ? { ...anchor, isPrepared: false } : anchor))\r\n          );\r\n          resetOriginCoords(100);\r\n        }, TRANSITION_TIME);\r\n        break;\r\n      }\r\n    }\r\n  }, [\r\n    answersAnchors,\r\n    answersWords,\r\n    dragEndEvent,\r\n    draggableId,\r\n    waitingWords,\r\n    translateDragElemFromAnswers,\r\n    translateWaitingWords,\r\n  ]);\r\n\r\n  return (\r\n    <div className=\"quiz\">\r\n      <Title content=\"Translate this sentence\" />\r\n      <div className=\"quiz-info\">\r\n        <Avatar />\r\n        <Sentence>\r\n          {sentenceText.map((word, index) => (\r\n            <li key={index}>\r\n              <SentenceWord content={word.text} />\r\n            </li>\r\n          ))}\r\n        </Sentence>\r\n      </div>\r\n      <div className=\"answers-wrapper\">\r\n        <DropArea\r\n          dragStartHandler={dragStartHandler}\r\n          dragMoveHandler={dragMoveHandler}\r\n          dragEndHandler={dragEndHandler}\r\n          originCoords={answersOriginCoords}\r\n          areaName=\"answersArea\"\r\n          words={answersWords}\r\n          anchors={answersAnchors}\r\n          isTransitioned={isTransitioned.current}\r\n          isBlockAnimaton={isBlockAnimaton}\r\n          ref={answersRef}\r\n        />\r\n      </div>\r\n      <div className=\"waiting-wrapper\">\r\n        <DropArea\r\n          dragStartHandler={dragStartHandler}\r\n          dragMoveHandler={dragMoveHandler}\r\n          dragEndHandler={dragEndHandler}\r\n          originCoords={waitingOriginCoords}\r\n          areaName=\"waitingArea\"\r\n          words={waitingWords}\r\n          anchors={getCorrectAnchors(words, 'waiting')}\r\n          isTransitioned={isTransitioned.current}\r\n          isBlockAnimaton={isBlockAnimaton}\r\n          ref={waitingRef}\r\n        />\r\n      </div>\r\n      <Message content={resultMessage} isError={isError} />\r\n      <div className=\"btn-wrapper\">\r\n        <Button\r\n          isTranslate={resultMessage}\r\n          onclickHandler={isBlockAnimaton ? null : checkAnswerHandler}\r\n          content=\"click\"\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Quiz;\r\n","const db = {\r\n  q1: {\r\n    sentenceWords: [\r\n      { text: 'He', translation: 'Он' },\r\n      { text: 'eats', translation: 'Ест' },\r\n      { text: 'fish', translation: 'Рыбу' },\r\n      { text: 'at', translation: '' },\r\n      { text: 'home', translation: 'дома' },\r\n    ],\r\n    answersWords: ['ест', 'он', 'дома', 'рыбу'],\r\n  },\r\n};\r\n\r\nexport default db;\r\n","import React from 'react';\r\nimport './App.scss';\r\nimport Quiz from './pages/Quiz/Quiz';\r\nimport db from './db';\r\n\r\nconst { sentenceWords, answersWords } = db.q1;\r\nconst App = () => {\r\n  return (\r\n    <div className=\"App\">\r\n      <Quiz sentenceText={sentenceWords} words={answersWords} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\nreportWebVitals();\n"],"sourceRoot":""}